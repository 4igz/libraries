[{"title":"Network","type":0,"sectionRef":"#","url":"api/Network","content":"On this page Network An advanced network module for easy server-client communication. The network module it self consists of a NetworkServer and a NetworkClient module, so whenever you require the Network module it self, in return one of these 2 modules are required and returned, based off of the environment (server / client). -- Server local Network = require(...) local networkObject = Network.new(&quot;Test&quot;) networkObject:append(&quot;method&quot;, function(player) return (&quot;hi, %s!&quot;):format(player.Name) end) networkObject:dispatch(workspace) -- Client local Network = require(...) local networkObject = Network.fromParent(&quot;Test&quot;, workspace) print(networkObject.Method()) --&gt; &quot;hi, bubshayz!&quot; ","keywords":""},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#properties","content":" "},{"title":"updated​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#updated","content":"This item is read only and cannot be modified. Read Only Signal ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty.updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the client in the serverside remote property (to which the client remote property is connected to) is updated. The signal is only passed the new updated value as the only argument.  "},{"title":"ClientRemoteProperty​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#ClientRemoteProperty","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; ClientRemoteProperty.ClientRemoteProperty: Type An exported Luau type of a client remote property object. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#functions","content":" "},{"title":"is​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#is","content":"&lt;/&gt; ClientRemoteProperty.is(self: any) → boolean Returns a boolean indicating if self is a client remote property or not.  "},{"title":"get​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#get","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:get() → any Returns the value of the client stored in the serverside remote property ( to which the client remote property is connected to).  "},{"title":"destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#destroy","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:destroy() → () Destroys the client remote property and renders it unusable. "},{"title":"MatrixUtil","type":0,"sectionRef":"#","url":"api/MatrixUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#functions","content":" "},{"title":"getMatchingRowsValue​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#getMatchingRowsValue","content":"&lt;/&gt; MatrixUtil.getMatchingRowsValue( matrix: {{any}}, depth: number? ) → any Searches matrix row wise, and returns a value in a row which matches with the rest of the values of that row. E.g: local matrix = { {1, 1, 1}, {5, 5, 2}, {0, 0, 2}, } print(MatrixUtil.getMatchingRowsValue(matrix)) --&gt; 1 (The first row is equally matched (all 1s)) Additionally, you can specify depth if you want to control how far the method should check each row. For e.g: local matrix = { {1, 2, 3, 4}, {5, 6, 7, 8}, {1, 1, 1, 0}, } print(MatrixUtil.getMatchingRowsValue(matrix, 3)) --&gt; 1 (The last row's first 3 values (1s) are equally matched) print(MatrixUtil.getMatchingRowsValue(matrix, 4)) --&gt; nil (No row's first 4 values are equally matched)   "},{"title":"getMatchingDiagonalColumnsValue​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#getMatchingDiagonalColumnsValue","content":"&lt;/&gt; MatrixUtil.getMatchingDiagonalColumnsValue( matrix: {{any}}, depth: number? ) → any Searches matrix diagonally, and returns a value which matches with the rest of the values of the arrays in matrix. E.g: local matrix = { {5, 0, 0}, {0, 5, 0}, {0, 0, 5}, } print(MatrixUtil.getMatchingDiagonalColumnsValue(matrix)) --&gt; 1 (A column has matching values diagonally (just 5s)) Additionally, you can specify depth if you want to control how far the method should search matrix diagonally. For e.g: local matrix = { {2, 0, 0, 0}, {0, 2, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}, } print(MatrixUtil.getMatchingDiagonalColumnsValue(matrix, 3)) --&gt; 2 (A column has FIRST 3 matching values diagonally (just 2s))   "},{"title":"getMatchingColumnsValue​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#getMatchingColumnsValue","content":"&lt;/&gt; MatrixUtil.getMatchingColumnsValue( matrix: {{any}}, depth: number? ) → any Searches matrix column wise and returns a value of a column which matches with the rest of the values of that column. E.g: local matrix = { {5, 0, 0}, {5, 1, 0}, {5, 0, 1}, } print(MatrixUtil.getMatchingColumnsValue(matrix)) --&gt; 5 (A column has ALL equally matching values (just 5s)) Additionally, you can specify depth if you want to control how far the method should check each column. For e.g: local matrix = { {5, 0, 0}, {5, 0, 0}, {2, 1, 1}, } print(MatrixUtil.getMatchingColumnsValue(matrix, 2)) --&gt; 5 (A column has FIRST 2 matching values (just 5s))  "},{"title":"Queue","type":0,"sectionRef":"#","url":"api/Queue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Queue","url":"api/Queue#properties","content":" "},{"title":"progressed​","type":1,"pageTitle":"Queue","url":"api/Queue#progressed","content":"Signal Queue Instance &lt;/&gt; Queue.progressed: Signal&lt;callbackProgressed: () → (),deltaTime: number&gt; A signal which is fired whenever the queue is progressed, i.e an appended callback is called. The callback called is passed as the first argument, and a second argument, deltaTime is also passed (which is basically how long (in seconds) it was before callbackProgressed was called ever since it was appended).  "},{"title":"queue​","type":1,"pageTitle":"Queue","url":"api/Queue#queue","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; Queue.queue: Type An exported Luau type of a queue object. "},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"api/Queue#new","content":"&lt;/&gt; Queue.new() → Queue A constructor method which creates a new queue object.  "},{"title":"is​","type":1,"pageTitle":"Queue","url":"api/Queue#is","content":"&lt;/&gt; Queue.is(self: any) → boolean A method which returns a boolean indicating if self is a queue or not.  "},{"title":"emptyQueue​","type":1,"pageTitle":"Queue","url":"api/Queue#emptyQueue","content":"Queue Instance &lt;/&gt; Queue:emptyQueue() → () Empties the queue, i.e all appended callbacks that are waiting to be resumed will never be resumed local Queue = require(...) local queue = Queue.new() local promise1 = queue:append(function() task.wait(1) warn(&quot;called&quot;) --&gt; this never works, because the promise is cancelled -- as the queue is emptied! end) print(promise1:getStatus()) --&gt; &quot;Running&quot; (the promise is running) queue:emptyQueue() print(promise1:getStatus()) --&gt; &quot;Cancelled&quot; (the promise has been cancelled)   "},{"title":"append​","type":1,"pageTitle":"Queue","url":"api/Queue#append","content":"Queue Instance &lt;/&gt; Queue:append(callback: (deltaTime: number) → ()) → Promise&lt;deltaTime: number&gt; Appends callback to the queue so that it'll be called once the previous callbacks appended to the queue have finished running (or the promises associated to them have been cancelled). callback upon being called is passed a number as the only argument (the time it took for it to be called ever since it was appended). The method also returns a promise, which too resolves with a number (the time it took for callback to run ever since it was appended), once callback is called. local Queue = require(...) local queue = Queue.new() local promise1 = queue:append(function(deltaTime) print(deltaTime) --&gt; 5.00003807246685e-07 task.wait(5) end) local promise2 = queue:append(function(deltaTime) print(deltaTime) --&gt; 5.0113310999877285 task.wait(1) end) local promise2 = queue:append(function(deltaTime) print(deltaTime) --&gt; 6.012134199991124 end) tip The promise returned will be cancelled if Queue:EmptyQueue is called, but you can also manually just cancel the promise to effectively remove the added callback from the queue, e.g: local Queue = require(...) local queue = Queue.new() local promise = queue:append(function(deltaTime) print(deltaTime) --&gt; never prints! end) promise:cancel() --&gt; Cancel the promise!   "},{"title":"destroy​","type":1,"pageTitle":"Queue","url":"api/Queue#destroy","content":"Queue Instance &lt;/&gt; Queue:destroy() → () Calls Queue:EmptyQueue and renders the queue unusable. "},{"title":"Property","type":0,"sectionRef":"#","url":"api/Property","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Property","url":"api/Property#properties","content":" "},{"title":"updated​","type":1,"pageTitle":"Property","url":"api/Property#updated","content":"This item is read only and cannot be modified. Read Only Signal Property Instance &lt;/&gt; Property.updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"Property​","type":1,"pageTitle":"Property","url":"api/Property#Property","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; Property.Property: Type An exported Luau type of a property object. "},{"title":"Functions​","type":1,"pageTitle":"Property","url":"api/Property#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Property","url":"api/Property#new","content":"&lt;/&gt; Property.new(initialValue: any) → Property A constructor method which creates a new property object, with initialValue as the current value of the property.  "},{"title":"is​","type":1,"pageTitle":"Property","url":"api/Property#is","content":"&lt;/&gt; Property.is(self: any) → boolean A method which returns a boolean indicating if self is a property or not.  "},{"title":"set​","type":1,"pageTitle":"Property","url":"api/Property#set","content":"Property Instance &lt;/&gt; Property:set(value: any) → () Sets the value of the property to value, if this new value isn't the same as the previous value.  "},{"title":"deferredSet​","type":1,"pageTitle":"Property","url":"api/Property#deferredSet","content":"Property Instance &lt;/&gt; Property:deferredSet(value: any) → () Works exactly the same as Property:set, except the updating of the property's value to value is deferred through task.defer.  "},{"title":"forceSet​","type":1,"pageTitle":"Property","url":"api/Property#forceSet","content":"Property Instance &lt;/&gt; Property:forceSet(value: any) → () Works exactly the same as Property:set except that tables aren't checked for equality, e.g: local Property = require(...) local property = Property.new() property.updated:Connect(function(newVal) warn(newVal) --&gt; {1} end) local t = {1} property:forceSet(t) --&gt; Fires off the .Updated signal (expected) -- This ought to not fire off the signal, but the previous and new value -- aren't checked for equality since they're both tables) property:forceSet(t) -- Fires off the .Updated signal (expected as a number ~= table) property:forceSet(1) -- Does NOT fire off the .Updated signal, since the previous value -- (a number, not a table) and the new value (a number, not a table) are the -- same! property:forceSet(1)   "},{"title":"bulkSet​","type":1,"pageTitle":"Property","url":"api/Property#bulkSet","content":"Property Instance &lt;/&gt; Property:bulkSet(value: any) → () Works almost exactly the same as Property:set, but never fires off the Property.updated signal.  "},{"title":"get​","type":1,"pageTitle":"Property","url":"api/Property#get","content":"Property Instance &lt;/&gt; Property:get() → any Returns the current value of the property. local Property = require(...) local property = Property.new() property:Set(5) print(property:get()) --&gt; 5   "},{"title":"destroy​","type":1,"pageTitle":"Property","url":"api/Property#destroy","content":"Property Instance &lt;/&gt; Property:destroy() → () Destroys the property and renders it unusable. "},{"title":"InstanceUtil","type":0,"sectionRef":"#","url":"api/InstanceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#functions","content":" "},{"title":"setInstanceProperties​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#setInstanceProperties","content":"&lt;/&gt; InstanceUtil.setInstanceProperties( instance: Instance , properties: {[string]: any} ) → () Sets the properties of instance from the properties table. local InstanceUtil = require(...) InstanceUtil.setInstanceProperties(workspace.Baseplate, {Transparency = 1}) print(workspace.Baseplate.Transparency) --&gt; 1   "},{"title":"setInstanceAttributes​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#setInstanceAttributes","content":"&lt;/&gt; InstanceUtil.setInstanceAttributes( instance: Instance , attributes: {[string]: any} ) → () Sets the attributes of instance from the attributes table. local InstanceUtil = require(...) InstanceUtil.setInstanceAttributes(workspace.Baseplate, {IsMayoSauce = true}) print(workspace.Baseplate:GetAttribute(&quot;IsMayoSauce&quot;)) --&gt; true   "},{"title":"setInstancePhysicsCollisionGroup​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#setInstancePhysicsCollisionGroup","content":"&lt;/&gt; InstanceUtil.setInstancePhysicsCollisionGroup( instance: Instance , collisionGroup: string ) → () Sets the collision group of instance to collisionGroup, if it is a BasePart. Else, all the descendants of instance (BaseParts') will have their collision group set to collisionGroup.  "},{"title":"resetInstancePhysicsCollisionGroup​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#resetInstancePhysicsCollisionGroup","content":"&lt;/&gt; InstanceUtil.resetInstancePhysicsCollisionGroup(instance: Instance ) → () Sets the collision group of instance to the default collision group i.e &quot;Default&quot;, if it is a BasePart. Else, all the descendants of instance (BaseParts') will have their collision group set to &quot;Default&quot;.  "},{"title":"setInstancePhysicalProperties​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#setInstancePhysicalProperties","content":"&lt;/&gt; InstanceUtil.setInstancePhysicalProperties( instance: Instance , physicalProperties: PhysicalProperties ) → () Sets the PhysicalProperties of instance to physicalProperties, if it is a BasePart. Else, all the descendants of instance (BaseParts') will have their PhysicalProperties set to physicalProperties. local physicalProperties = PhysicalProperties.new(1) InstanceUtil.setInstancePhysicalProperties(workspace.Baseplate, physicalProperties)   "},{"title":"resetInstancePhysicalProperties​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#resetInstancePhysicalProperties","content":"&lt;/&gt; InstanceUtil.resetInstancePhysicalProperties(instance: Instance ) → () Sets the PhysicalProperties of instance to the default, if it is a BasePart. Else, all the descendants of instance (BaseParts') will have their PhysicalProperties set to the default.  "},{"title":"getInstanceCorners​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#getInstanceCorners","content":"&lt;/&gt; InstanceUtil.getInstanceCorners(instance: BasePart ) → { top: {Vector3 }, bottom: {Vector3 } } Returns a read only dictionary of all corners of instance, top and bottom.  "},{"title":"getInstanceFloorMaterial​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#getInstanceFloorMaterial","content":"&lt;/&gt; InstanceUtil.getInstanceFloorMaterial( instance: BasePart , raycastParams: RaycastParams?, depth: number? ) → EnumItem  Returns the material the instance is lying on. If instance is under water, then Enum.Material.Water will be returned, elseif instance is in air, then Enum.Material.Air will be returned. The 2nd argument can be passed as a RaycastParams object, which will be used in determining the material of instance through ray casting. The 3rd argument can be passed as a number (depth) which will increase the length of the ray by depth studs (on the Y axis). This is only useful when you want to add in more leeway in determining the material of instance reliably, since sometimes the instance may be very slightly over the top of some ground due to it's geometr so in those cases, the ray may not register properly. If this argument isn't specified, then it will default to 0.01.   "},{"title":"setInstanceNetworkOwner​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#setInstanceNetworkOwner","content":"&lt;/&gt; InstanceUtil.setInstanceNetworkOwner( instance: BasePart , networkOwner: Player? ) → () Sets the network owner of instance to networkOwner safely. tip This method should be preferred over directly setting the network owner of instance via SetNetworkOwner, as it won't error in cases where the network ownership API cannot be used on instance.  "},{"title":"getInstanceNetworkOwner​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#getInstanceNetworkOwner","content":"&lt;/&gt; InstanceUtil.getInstanceNetworkOwner(instance: BasePart ) → Player?  Returns the network owner of instance safely. tip This method should be preferred over directly getting the network owner of instance via GetNetworkOwner, as it will safely return nil in cases where the network ownership API cannot be used on instance. "},{"title":"EnumList","type":0,"sectionRef":"#","url":"api/EnumList","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"EnumList","url":"api/EnumList#properties","content":" "},{"title":"EnumList​","type":1,"pageTitle":"EnumList","url":"api/EnumList#EnumList","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; EnumList.EnumList: Type An exported Luau type of an EnumList object. local EnumList = require(...) local MyEnumList : EnumList.EnumList = EnumList.new(...)  "},{"title":"Functions​","type":1,"pageTitle":"EnumList","url":"api/EnumList#functions","content":" "},{"title":"new​","type":1,"pageTitle":"EnumList","url":"api/EnumList#new","content":"&lt;/&gt; EnumList.new( name: string, enums: {[string]: {[string]: any}} ) → EnumList A constructor method which creates a new enum list out of enumItems, with the name of name. local EnumList = require(...) local MyEnumList = EnumList.new(&quot;Enums&quot;, {Test = 123}) print(MyEnumList.Test) --&gt; 123   "},{"title":"is​","type":1,"pageTitle":"EnumList","url":"api/EnumList#is","content":"&lt;/&gt; EnumList.is(self: any) → boolean A method which returns a boolean indicating if self is a enumlist or not.  "},{"title":"getName​","type":1,"pageTitle":"EnumList","url":"api/EnumList#getName","content":"EnumList instance &lt;/&gt; EnumList:getName() → string Returns the name of the enum list.  "},{"title":"getEnums​","type":1,"pageTitle":"EnumList","url":"api/EnumList#getEnums","content":"EnumList instance &lt;/&gt; EnumList:getEnums() → {[string]: CustomEnum} Returns the enums of the enum list. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Disconnect: () → () Connected: boolean }  "},{"title":"Properties​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#properties","content":" "},{"title":"RemoteSignal​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#RemoteSignal","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; RemoteSignal.RemoteSignal: Type An exported Luau type of a remote signal object. "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#new","content":"&lt;/&gt; RemoteSignal.new() → RemoteSignal Creates and returns a new remote signal.  "},{"title":"is​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#is","content":"&lt;/&gt; RemoteSignal.is(self: any) → boolean Returns a boolean indicating if self is a remote signal or not.  "},{"title":"connectOnce​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#connectOnce","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:connectOnce(callback: (...any) → ()) → SignalConnection Works almost exactly the same as RemoteSignal:connectOnce, except the connection returned is disconnected automaticaly once callback is called.  "},{"title":"connect​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#connect","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:connect(callback: (...any) → ()) → SignalConnection Connects callback to the remote signal so that it is called whenever the client fires the remote signal, and callback will be passed arguments sent by the client.  "},{"title":"fireForClients​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#fireForClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireForClients( clients: {Player }, ...: any ) → () Fires the arguments ... to every client in the clients table only.  "},{"title":"fireClient​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#fireClient","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireClient( client: Player , ...: any ) → () Fires the arguments ... to client.  "},{"title":"fireAllClients​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#fireAllClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireAllClients(...: any) → () Fires the arguments ... to every client in the game.  "},{"title":"disconnectAll​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#disconnectAll","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:disconnectAll() → () Disconnects all connections connected via RemoteSignal:connect or RemoteSignal:connectOnce.  "},{"title":"destroy​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#destroy","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:destroy() → () Destroys the remote signal and renders it unusable. "},{"title":"NetworkClient","type":0,"sectionRef":"#","url":"api/NetworkClient","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"NetworkClient","url":"api/NetworkClient#functions","content":" "},{"title":"allFromParent​","type":1,"pageTitle":"NetworkClient","url":"api/NetworkClient#allFromParent","content":"&lt;/&gt; NetworkClient.allFromParent(parent: Instance ) → {[string]: {[string]: any}} Returns an array of all network objects dispatched to parent. -- Server local Network = require(...) local networkObject1 = Network.new(&quot;Test1&quot;, workspace) networkObject:append(&quot;status&quot;, &quot;not good mate&quot;) networkObject:dispatch() local networkObject2 = Network.new(&quot;Test2&quot;, workspace) networkObject:append(&quot;status&quot;, &quot;good mate!&quot;) networkObject:dispatch() -- Client local Network = require(...) for _, networkObject in Network.allFromParent(workspace) do print(networkObject.status) end --&gt; &quot;not good mate&quot; --&gt; &quot;good mate!&quot;   "},{"title":"fromParent​","type":1,"pageTitle":"NetworkClient","url":"api/NetworkClient#fromParent","content":"&lt;/&gt; NetworkClient.fromParent( name: string, parent: Instance ) → Promise&lt;DispatchedNetworkObject: {[string]: any}&gt; Returns a promise which is resolved (with the network object) once a network object of name i.e name, is found in parent. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"api/RemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#properties","content":" "},{"title":"updated​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#updated","content":"This item is read only and cannot be modified. Read Only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the remote property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"clientValueUpdated​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#clientValueUpdated","content":"This item is read only and cannot be modified. Read Only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.clientValueUpdated: Signal&lt;player: Player, newValue: any&gt; A signal which is fired whenever the value of player specifically in the remote property is set to a new one. The signal is passed the player as the first argument, and the new specific value of player set in the remote property as the second argument.  "},{"title":"RemoteProperty​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#RemoteProperty","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; RemoteProperty.RemoteProperty: Type An exported Luau type of a remote property object. "},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#new","content":"&lt;/&gt; RemoteProperty.new(initialValue: any) → RemoteProperty Creates and returns a new remote property with the value of initialValue.  "},{"title":"is​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#is","content":"&lt;/&gt; RemoteProperty.is(self: any) → boolean Returns a boolean indicating if self is a remote property or not.  "},{"title":"get​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#get","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:get() → any Returns the current value set for the remote property.  "},{"title":"setForClients​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#setForClients","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setForClients( clients: {Player }, value: any ) → () Sets a value of the remote property for every client in clients table, specifically, to value.  "},{"title":"setForClient​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#setForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setForClient( client: Player , value: any ) → () Sets a value of the remote property for client specifically, to value.  "},{"title":"removeForClient​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#removeForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:removeForClient(client: Player ) → () Removes the value stored for client specifically in the the remote property.  "},{"title":"removeForClients​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#removeForClients","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:removeForClients(clients: {Player }) → () Removes the value of the remote property stored specifically for every client in clients table.  "},{"title":"clientHasValueSet​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#clientHasValueSet","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:clientHasValueSet(client: Player ) → boolean Returns a boolean indicating if there is a specific value stored for client in the remote property.  "},{"title":"getForClient​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#getForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:getForClient(client: Player ) → any Returns the value stored specifically for client in the remote property.  "},{"title":"set​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#set","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:set(value: any) → () Sets the value of the remote property to value, and so for all other clients (who can access this value through a client remote property), who don't have a specific value for them stored in the remote property.  "},{"title":"destroy​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#destroy","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:destroy() → () Destroys the remote property and renders it unusable. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Setup​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-setup","content":"Once Wally is installed, run wally init on your project directory, and then add the various open sourced modules that you need, as wally dependencies. For e.g, the following may be a wally.toml file for a project that includes a NumberUtil wally package: [package] name = &quot;your_name/your_project_name&quot; version = &quot;1.0.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] InstanceUtil = &quot;bubshayz/instanceutil@1.0.8&quot; Copy Now, to install these dependencies, run wally install within your project. Wally will then create a package folder in your directory with the installed dependencies. Then use Rojo to sync in the package folder to Studio. "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"docs/intro#usage-example","content":"Once the above necessary steps are completed, the installed wally dependencies can now be used in code, e.g: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local NumberUtil = require(ReplicatedStorage.Packages.NumberUtil) print(NumberUtil.Factors(2)) --&gt; {1, 2} Copy "},{"title":"CustomEnum","type":0,"sectionRef":"#","url":"api/CustomEnum","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CustomEnum","url":"api/CustomEnum#functions","content":" "},{"title":"getEnumItems​","type":1,"pageTitle":"CustomEnum","url":"api/CustomEnum#getEnumItems","content":"CustomEnum instance &lt;/&gt; CustomEnum:getEnumItems() → {[string]: any} Returns the enum items of the enum. local EnumList = require(...) local enumList = EnumList.new(&quot;EnumList&quot;, { PhoneNumber = { -- Custom Enum BabaBoey = 123, } }) local enumItems = enumList.PhoneNumber:getEnumItems() print(enumItems == enumList.PhoneNumber) --&gt; true print(enumItems.BabaBoey) --&gt; 123   "},{"title":"getName​","type":1,"pageTitle":"CustomEnum","url":"api/CustomEnum#getName","content":"CustomEnum instance &lt;/&gt; CustomEnum:getName() → string Returns the name of the custom enum. "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Disconnect: () → () Connected: boolean }  "},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#properties","content":" "},{"title":"ClientRemoteSignal​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#ClientRemoteSignal","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; ClientRemoteSignal.ClientRemoteSignal: Type An exported Luau type of a client remote signal object. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"is​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#is","content":"&lt;/&gt; ClientRemoteSignal.is(self: any) → boolean Returns a boolean indicating if self is a client remote signal or not.  "},{"title":"connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#connect","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:connect(callback: (...any) → ()) → SignalConnection Connects callback to the client remote signal so that it is called whenever the serverside remote signal (to which the client remote signal is connected to) dispatches some data to the client remote signal. The connected callback is called with the data dispatched to the client remote signal.  "},{"title":"connectOnce​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#connectOnce","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:connectOnce(callback: (...any) → ()) → SignalConnection Works almost exactly the same as ClientRemoteSignal:connect, except the connection returned is disconnected immediately upon callback being called.  "},{"title":"disconnectAll​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#disconnectAll","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:disconnectAll() → () Disconnects all connections connected via ClientRemoteSignal:connect or ClientRemoteSignal:connectOnce.  "},{"title":"fireServer​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#fireServer","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:fireServer(...: any) → () Fires ... arguments to the serverside remote signal (to which the client remote signal is connected to).  "},{"title":"wait​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#wait","content":"ClientRemoteSignal instance yields &lt;/&gt; ClientRemoteSignal:wait() → () Yields the thread until the serverside remote signal (to which the client remote signal is connected to) dispatches some data to this client remote signal.  "},{"title":"destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#destroy","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:destroy() → () Destroys the client remote signal and renders it unusable. "},{"title":"WindLines","type":0,"sectionRef":"#","url":"api/WindLines","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"WindLines","url":"api/WindLines#types","content":" "},{"title":"WindLinesConfig​","type":1,"pageTitle":"WindLines","url":"api/WindLines#WindLinesConfig","content":"&lt;/&gt; interface WindLinesConfig { lifetime: number-- The life time of wind lines. direction: number-- The direction of wind lines. speed: number-- The speed at which wind lines move. spawnRate: number-- The rate at which wind lines are created. raycastParams: RaycastParams-- A RaycastParams object, to be used in determining if the player is under a roof or not. } This is a config template, none of these members are required in the config table when configuring WindLines through WindLines.SetConfig, however the config table must not be empty!  "},{"title":"DefaultWindLinesConfig​","type":1,"pageTitle":"WindLines","url":"api/WindLines#DefaultWindLinesConfig","content":"&lt;/&gt; interface DefaultWindLinesConfig { lifetime: 3 direction: Vector3.xAxis speed: 6 spawnRate: 25 raycastParams: nil } This is the default config template that WindLines initially uses. You can configure WindLines through WindLines.SetConfig. "},{"title":"Properties​","type":1,"pageTitle":"WindLines","url":"api/WindLines#properties","content":" "},{"title":"effectStarted​","type":1,"pageTitle":"WindLines","url":"api/WindLines#effectStarted","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; WindLines.effectStarted: Signal&lt;&gt; A signal which is fired whenever the wind lines effect starts.  "},{"title":"effectStopped​","type":1,"pageTitle":"WindLines","url":"api/WindLines#effectStopped","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; WindLines.effectStopped: Signal&lt;&gt; A signal which is fired whenever the wind lines effect stops. "},{"title":"Functions​","type":1,"pageTitle":"WindLines","url":"api/WindLines#functions","content":" "},{"title":"isEffectStarted​","type":1,"pageTitle":"WindLines","url":"api/WindLines#isEffectStarted","content":"&lt;/&gt; WindLines.isEffectStarted() → boolean Returns a boolean indicating if the wind lines effect has started.  "},{"title":"isStarted​","type":1,"pageTitle":"WindLines","url":"api/WindLines#isStarted","content":"&lt;/&gt; WindLines.isStarted() → boolean Returns a boolean indicating if WindLines, the module it self, is started through WindLines.start.  "},{"title":"setConfig​","type":1,"pageTitle":"WindLines","url":"api/WindLines#setConfig","content":"&lt;/&gt; WindLines.setConfig(newConfig: WindLinesConfig) → () Sets the current config of WindLines to newConfig, which means that this new config will be used for wind line effects. warning You cannot configure WindLines once it is started, so always make sure to call this method before you start WindLines!  "},{"title":"start​","type":1,"pageTitle":"WindLines","url":"api/WindLines#start","content":"&lt;/&gt; WindLines.start() → () Starts up the wind lines effect. tip If the player is standing under a roof, then the wind lines effect will be stopped for realism purposes and this behavior cannot be toggled. However, you can adjust this behavior through WindLines:SetConfig through the RaycastParams member, since ray casting is used in determining if the player is standing under a roof. E.g, the following config does not consider descendants in the filteredPartsFolder folder as roofs, so if a player stands under them, the wind lines effect will not be stopped: local Workspace = game:GetService(&quot;Workspace&quot;) local WindLines = require(...) local filteredPartsFolder = Workspace.SomeFolder local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {filteredPartsFolder} WindLines.setConfig({RaycastParams = raycastParams}) WindLines.start()   "},{"title":"stop​","type":1,"pageTitle":"WindLines","url":"api/WindLines#stop","content":"&lt;/&gt; WindLines.stop() → () Stops the wind lines effect. "},{"title":"NumberUtil","type":0,"sectionRef":"#","url":"api/NumberUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#properties","content":" "},{"title":"e​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#e","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.e: number&lt;2.7182818284590&gt; A mathematical constant, also known as Euler's number.  "},{"title":"Phi​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Phi","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.Phi: number&lt;1.618033988749895&gt; A mathematical constant, also known as the golden ratio.  "},{"title":"Tau​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Tau","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.Tau: number&lt;6.283185307179586&gt; A mathematical constant, it is the circle constant representing the ratio between circumference and radius.  "},{"title":"G​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#G","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.G: number&lt;6.6743e-11&gt; A mathematical constant, used in calculating the gravitational attraction between two objects. "},{"title":"Functions​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#functions","content":" "},{"title":"lerp​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#lerp","content":"&lt;/&gt; NumberUtil.lerp( number: number, goal: number, alpha: number ) → number Interpolates number to goal, with alpha being the multiplier. local NumberUtil = require(...) local num = 2 local goal = 5 num = NumberUtil.lerp(num, goal, 0.7) print(num) --&gt; 4.1   "},{"title":"quadraticLerp​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#quadraticLerp","content":"&lt;/&gt; NumberUtil.quadraticLerp( number: number, goal: number, alpha: number ) → number Quadraticly interpolates number to goal, with alpha being the multiplier. local NumberUtil = require(...) local num = 2 local goal = 5 num = NumberUtil.quadraticLerp(num, goal, 0.7) print(num) --&gt; 4.1   "},{"title":"inverseLerp​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#inverseLerp","content":"&lt;/&gt; NumberUtil.inverseLerp( min: number, max: number, alpha: number ) → number Inverse Lerp is the inverse operation of the Lerp Node. It can be used to determine what the input to a Lerp was based on its output. For e.g, the value of a Lerp between 0 and 2 with alpha being 1 is 0.5. Therefore the value of an Inverse Lerp between 0 and 2 with alpha being 0.5 is 1. local NumberUtil = require(...) local num = 2 local goal = 5 num = NumberUtil.inverseLerp(num, goal, 0.7) print(num) --&gt; -0.43333333333333335   "},{"title":"average​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#average","content":"&lt;/&gt; NumberUtil.average( sum: number, ...: number ) → number Returns the average of ... numbers against sum. local NumberUtil = require(...) print(NumberUtil.inverseLerp(100, 50, 25)) --&gt; 0.75   "},{"title":"format​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#format","content":"&lt;/&gt; NumberUtil.format(number: number) → string Return a string as the formatted version of number. warning This method will struggle to format numbers larger than 10^66. local NumberUtil = require(...) print(NumberUtil.format(1650)) --&gt; &quot;1.65K&quot;   "},{"title":"map​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#map","content":"&lt;/&gt; NumberUtil.map( number: number, inMin: number, inMax: number, outMin: number, outMax: number ) → number Maps number between inMin and inMax, and outMin and outMax. local NumberUtil = require(...) print(NumberUtil.map(1,2,3,4,5)) --&gt; 3   "},{"title":"nan​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#nan","content":"&lt;/&gt; NumberUtil.nan(number: number) → boolean Returns a boolean indicating if number is NaN (Not A Number). local NumberUtil = require(...) print(NumberUtil.nan(0 / 0)) --&gt; true   "},{"title":"close​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#close","content":"&lt;/&gt; NumberUtil.close( number: number, to: number, eplison: number? ) → boolean Returns a boolean indicating if the difference between number and to is lower than or equal to eplsion. local NumberUtil = require(...) print(NumberUtil.close(0.1 + 0.2, 0.3)) --&gt; true print(NumberUtil.close(0.1 + 0.2, 0.3, 0)) --&gt; false If eplison is not specified, then it will default to 1e-5.  "},{"title":"root​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#root","content":"&lt;/&gt; NumberUtil.root( number: number, root: number ) → number Returns the root of number. local NumberUtil = require(...) print(NumberUtil.root(2, 3)) --&gt; 1.2599210498948732 (same as cube root of 2) print(NumberUtil.root(2, 2)) --&gt; 1.4142135623730951 (same as square root of 2)   "},{"title":"factorial​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#factorial","content":"&lt;/&gt; NumberUtil.factorial(number: number) → number Returns the factorial of number. local NumberUtil = require(...) print(NumberUtil.factorial(3)) --&gt; 6   "},{"title":"factors​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#factors","content":"&lt;/&gt; NumberUtil.factors(number: number) → {number} Returns an array of all factors of number. local NumberUtil = require(...) print(NumberUtil.factors(2)) --&gt; {1, 2}   "},{"title":"clampTo​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#clampTo","content":"&lt;/&gt; NumberUtil.clampTo( number: number, min: number, max: number, clamp: number ) → number Clamps number to clamp, if number is greater than max or lower than min. local NumberUtil = require(...) print(NumberUtil.clampTo(1, 2, 5, 150)) --&gt; 150  "},{"title":"NetworkServer","type":0,"sectionRef":"#","url":"api/NetworkServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#Middleware","content":"&lt;/&gt; interface Middleware { inbound: {(args: {...any}) → ()}? outbound: {(args: {...any}) → ()}? } Both Inbound and Outbound should be array of callbacks (if specified, none of them are required). Callbacks in Inbound are known as &quot;inbound callbacks&quot; and are called whenever a client tries to call a serverside method (exposed through the network object). The first argument passed to each inbound callback is the name of the method (the client called), and the arguments sent by the client (to that method) are packed into an array, which is then passed as the second argument. local inboundCallbacks = { function (methodName, arguments) print(arguments[1]:IsA(&quot;Player&quot;)) --&gt; true (first argument is always the client) arguments[2] = &quot;booooo&quot; --&gt; You can modify the arguments ! end } --- Automatic method call rejection If any inbound callback returns an explicit false value, then the method (which the client tried to call) will not be called. This is good, e.g for implementing queues! Callbacks in Outbound are known as &quot;outbound callbacks&quot; and are called whenever a serverside method (exposed through the network object) is called by the client, and has finished. The first argument passed to each inbound callback is the name of the method (the client called), and the arguments sent by the client (to that method) are packed into an array, which is then passed as the second argument. local outboundCallbacks = { function (methodName, arguments) print(arguments[1]:IsA(&quot;Player&quot;)) --&gt; true (first argument is always the client) end } --- tip For outbound callbacks, an additional member in the arguments array, i.e response is injected automatically, which is the response of the serverside method (which the client called). This means you can modify the response of the serverside method before it is returned back to the client, e.g: -- Server: local Network = require(...) local middleware = { { function (methodName, arguments) arguments.response = &quot;oops modified&quot; end } } local networkObject = Network.new(&quot;test&quot;, middleware) networkObject:append(&quot;SomeMethod&quot;, function() return &quot;this&quot; end) networkObject:dispatch(workspace) -- Client: local Network = require(...) local networkObject = Network.FromName(&quot;test&quot;, workspace):expect() print(networkObject.SomeMethod()) --&gt; &quot;oops modified&quot; (ought to print &quot;this&quot;)  "},{"title":"Functions​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#new","content":"&lt;/&gt; NetworkServer.new( name: string, middleware: Middleware? ) → NetworkServer Creates and returns a new network object of the name i.e name. Internally, a folder is created for each newly created network object, which too is named to name, but the folder it self is initially parented to nil so the network object isn't available to the client - call NetworkServer:Dispatch in order to render the network object accessible to the client.  "},{"title":"is​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#is","content":"&lt;/&gt; NetworkServer.is(self: any) → boolean Returns a boolean indicating if self is a network object or not.  "},{"title":"dispatched​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#dispatched","content":"&lt;/&gt; NetworkServer:dispatched() → boolean Returns a boolean indicating if the network object is dispatched to the client or not. note This method will always return false if the network object is destroyed.  "},{"title":"append​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#append","content":"&lt;/&gt; NetworkServer:append( key: string, value: RemoteProperty | RemoteSignal | any ) → () Appends a key value pair, key and value, to the network object, so that it is available to the client once the network object is dispatched. E.g: -- Server local Network = require(...) local networkObject = Network.new(&quot;test&quot;) networkObject:append(&quot;key&quot;, &quot;the value!&quot;) networkObject:dispatch(workspace) -- Client local networkObject = Network.fromServer(&quot;test&quot;, workspace):expect() print(networkObject.key) --&gt; &quot;the value!&quot; note Argument limitations do apply since remote functions are internally used to replicate the appended key value pairs to the client. warning This method will error if the network object is dispatched to the client. Always make sure to append keys and values before you dispatch the network object. You can check if a network object is dispatched to the client or not through NetworkServer:dispatched.  "},{"title":"dispatch​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#dispatch","content":"&lt;/&gt; NetworkServer:dispatch(parent: Instance ) → () Dispatches the network folder of the network object to parent, rendering the network object accessible to the client now. warning If another network object of the same name as this network object, is already dispatched to parent, then this method will error - you can't have more than 1 network object of the same name dispatched to the same instance!  "},{"title":"destroy​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#destroy","content":"&lt;/&gt; NetworkServer:destroy() → () Destroys the network object and all appended remote properties / remote signals within the network object, and renders the network object useless. "}]