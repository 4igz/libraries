[{"title":"Network","type":0,"sectionRef":"#","url":"api/Network","content":"On this page Network The Network module it self consists of a NetworkServer and a NetworkClient module, so whenever you require the Network module it self, in return one of these 2 modules are required and returned, based off of the environment (server / client). -- Server local Network = require(...) local networkObject = Network.new(&quot;Test&quot;, workspace) networkObject:Append(&quot;method&quot;, function(player) return (&quot;hi, %s!&quot;):format(player.Name) end) networkObject:Dispatch() -- Client local Network = require(...) local networkObject = Network.FromName(&quot;Test&quot;, workspace) print(networkObject.Method()) --&gt; &quot;hi, bubshayz!&quot; ","keywords":""},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"api/ClientRemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#properties","content":" "},{"title":"Updated​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Updated","content":"This item is read only and cannot be modified. Read Only Signal ClientRemoteProperty Instance &lt;/&gt; ClientRemoteProperty.Updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the client in the serverside remote property (to which the client remote property is connected to) is updated. The signal is only passed the new updated value as the only argument. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#functions","content":" "},{"title":"IsA​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#IsA","content":"&lt;/&gt; ClientRemoteProperty.IsA(self: any) → boolean Returns a boolean indicating if self is a client remote property or not.  "},{"title":"Get​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Get","content":"&lt;/&gt; ClientRemoteProperty:Get() → any Returns the value of the client stored in the serverside remote property (to which the client remote property is connected to).  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"api/ClientRemoteProperty#Destroy","content":"&lt;/&gt; ClientRemoteProperty:Destroy() → () Destroys the client remote property and renders it unusable. "},{"title":"CustomEnum","type":0,"sectionRef":"#","url":"api/CustomEnum","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"CustomEnum","url":"api/CustomEnum#functions","content":" "},{"title":"GetEnumItems​","type":1,"pageTitle":"CustomEnum","url":"api/CustomEnum#GetEnumItems","content":"&lt;/&gt; CustomEnum:GetEnumItems() → {[string]: any} Returns the enum items of the enum. local EnumList = require(...) local enumList = EnumList.new(&quot;EnumList&quot;, { PhoneNumber = { -- Custom Enum BabaBoey = 123, } }) local enumItems = enumList.PhoneNumber:GetEnumItems() print(enumItems == enumList.PhoneNumber) --&gt; true print(enumItems.BabaBoey) --&gt; 123  "},{"title":"MatrixUtil","type":0,"sectionRef":"#","url":"api/MatrixUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#functions","content":" "},{"title":"GetMatchingRowsValue​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#GetMatchingRowsValue","content":"&lt;/&gt; MatrixUtil.GetMatchingRowsValue( matrix: {{any}}, depth: number? ) → any Searches matrix row wise, and returns a value in a row which matches with the rest of the values of that row. E.g: local matrix = { {1, 1, 1}, {5, 5, 2}, {0, 0, 2}, } print(MatrixUtil.GetMatchingRowsValue(matrix)) --&gt; 1 Additionally, you can specify depth if you want to control how far the method should check each row. For e.g: local matrix = { {1, 2, 3, 4}, {5, 6, 7, 8}, {1, 1, 1, 0}, } print(MatrixUtil.GetMatchingRowsValue(matrix, 3)) --&gt; 1 print(MatrixUtil.GetMatchingRowsValue(matrix, 0)) --&gt; nil   "},{"title":"GetMatchingDiagonalColumnsValue​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#GetMatchingDiagonalColumnsValue","content":"&lt;/&gt; MatrixUtil.GetMatchingDiagonalColumnsValue( matrix: {{any}}, depth: number? ) → any Searches matrix diagonally, and returns a value which matches with the rest of the values of the arrays in matrix. E.g: local matrix = { {1, 0, 0}, {0, 1, 0}, {0, 0, 1}, } print(MatrixUtil.GetMatchingDiagonalColumnsValue(matrix)) --&gt; 1 Additionally, you can specify depth if you want to control how far the method should search matrix diagonally. For e.g: local matrix = { {1, 0, 0, 0}, {0, 1, 0, 0}, {0, 0, 1, 0}, {0, 0, 0, 0}, } print(MatrixUtil.GetMatchingDiagonalColumnsValue(matrix, 3)) --&gt; 1   "},{"title":"GetMatchingColumnsValue​","type":1,"pageTitle":"MatrixUtil","url":"api/MatrixUtil#GetMatchingColumnsValue","content":"&lt;/&gt; MatrixUtil.GetMatchingColumnsValue( matrix: {{any}}, depth: number? ) → any Searches matrix column wise and returns a value of a column which matches with the rest of the values of that column. E.g: local matrix = { {5, 0, 0}, {5, 1, 0}, {5, 0, 1}, } print(MatrixUtil.GetMatchingColumnsValue(matrix)) --&gt; 5 Additionally, you can specify depth if you want to control how far the method should check each column. For e.g: local matrix = { {5, 0, 0}, {5, 0, 0}, {2, 1, 1}, } print(MatrixUtil.GetMatchingColumnsValue(matrix, 2)) --&gt; 5  "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Disconnect: () → () Connected: boolean }  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#functions","content":" "},{"title":"IsA​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#IsA","content":"&lt;/&gt; ClientRemoteSignal.IsA(self: any) → boolean Returns a boolean indicating if self is a client remote signal or not.  "},{"title":"Connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Connect","content":"&lt;/&gt; ClientRemoteSignal:Connect(callback: (...any) → any) → SignalConnection Connects callback to the client remote signal so that it is called whenever the serverside remote signal (to which the client remote signal is connected to) dispatches some data to the client remote signal. The connected callback is called with the data dispatched to the client remote signal.  "},{"title":"ConnectOnce​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#ConnectOnce","content":"&lt;/&gt; ClientRemoteSignal:ConnectOnce(callback: (...any) → any) → SignalConnection Works almost exactly the same as ClientRemoteSignal:Connect, except the connection returned is disconnected immediately upon callback being called.  "},{"title":"DisconnectAll​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#DisconnectAll","content":"&lt;/&gt; ClientRemoteSignal:DisconnectAll() → () Disconnects all connections connected via ClientRemoteSignal:Connect or ClientRemoteSignal:ConnectOnce.  "},{"title":"Fire​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Fire","content":"&lt;/&gt; ClientRemoteSignal:Fire(...: any) → () Fires ... arguments to the serverside remote signal (to which the client remote signal is connected to).  "},{"title":"Wait​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Wait","content":"yields &lt;/&gt; ClientRemoteSignal:Wait() → () Yields the thread until the serverside remote signal (to which the client remote signal is connected to) dispatches some data to the client remote signal.  "},{"title":"Destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"api/ClientRemoteSignal#Destroy","content":"&lt;/&gt; ClientRemoteSignal:Destroy() → () Destroys the client remote signal and renders it unusable. "},{"title":"NetworkClient","type":0,"sectionRef":"#","url":"api/NetworkClient","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"NetworkClient","url":"api/NetworkClient#functions","content":" "},{"title":"AllFromParent​","type":1,"pageTitle":"NetworkClient","url":"api/NetworkClient#AllFromParent","content":"&lt;/&gt; NetworkClient.AllFromParent(parent: Instance ) → {[string]: {[string]: any}} Returns an array of all network objects dispatched to parent. -- Server local Network = require(...) local networkObject1 = Network.new(&quot;Test1&quot;, workspace) networkObject:Append(&quot;status&quot;, &quot;not good mate&quot;) networkObject:Dispatch() local networkObject2 = Network.new(&quot;Test2&quot;, workspace) networkObject:Append(&quot;status&quot;, &quot;good mate!&quot;) networkObject:Dispatch() -- Client local Network = require(...) for _, networkObject in Network.AllFromParent(workspace) do print(networkObject.status) end --&gt; &quot;not good mate&quot; --&gt; &quot;good mate!&quot;   "},{"title":"FromName​","type":1,"pageTitle":"NetworkClient","url":"api/NetworkClient#FromName","content":"&lt;/&gt; NetworkClient.FromName( name: string, parent: Instance ) → Promise&lt;DispatchedNetworkObject: {[string]: any}&gt; Returns a promise which is resolved (with the network object) once a network object of name i.e name, is found in parent. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Wally Setup​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-setup","content":"Once Wally is installed, run wally init on your project directory, and then add the various open sourced modules that you need, as wally dependencies. For e.g, the following may be a wally.toml file for a project that includes a NumberUtil wally package: [package] name = &quot;your_name/your_project_name&quot; version = &quot;1.0.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] InstanceUtil = &quot;bubshayz/instanceutil@1.0.8&quot; Copy Now, to install these dependencies, run wally install within your project. Wally will then create a package folder in your directory with the installed dependencies. Then use Rojo to sync in the package folder to Studio. "},{"title":"Usage Example​","type":1,"pageTitle":"Getting Started","url":"docs/intro#usage-example","content":"Once the above necessary steps are completed, the installed wally dependencies can now be used in code, e.g: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local NumberUtil = require(ReplicatedStorage.Packages.NumberUtil) print(NumberUtil.Factors(2)) --&gt; {1, 2} Copy "},{"title":"WindLines","type":0,"sectionRef":"#","url":"api/WindLines","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"WindLines","url":"api/WindLines#types","content":" "},{"title":"WindLinesConfig​","type":1,"pageTitle":"WindLines","url":"api/WindLines#WindLinesConfig","content":"&lt;/&gt; interface WindLinesConfig { Lifetime: number-- The life time of wind lines. Direction: number-- The direction of wind lines. Speed: number-- The speed at which wind lines move. SpawnRate: number-- The rate at which wind lines are created. RaycastParams: RaycastParams-- A RaycastParams object, to be used in determining if the player is under a roof or not. } This is a config template, none of these members are required in the config table when configuring WindLines through WindLines.SetConfig, however the config table must not be empty!  "},{"title":"DefaultWindLinesConfig​","type":1,"pageTitle":"WindLines","url":"api/WindLines#DefaultWindLinesConfig","content":"&lt;/&gt; interface DefaultWindLinesConfig { Lifetime: 3 Direction: Vector3.xAxis Speed: 6 SpawnRate: 25 RaycastParams: nil } This is the default config template that WindLines initially uses. You can configure WindLines through WindLines.SetConfig. "},{"title":"Properties​","type":1,"pageTitle":"WindLines","url":"api/WindLines#properties","content":" "},{"title":"EffectStarted​","type":1,"pageTitle":"WindLines","url":"api/WindLines#EffectStarted","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; WindLines.EffectStarted: Signal&lt;&gt; A signal which is fired whenever the wind lines effect starts.  "},{"title":"EffectStopped​","type":1,"pageTitle":"WindLines","url":"api/WindLines#EffectStopped","content":"This item is read only and cannot be modified. Read Only Signal &lt;/&gt; WindLines.EffectStopped: Signal&lt;&gt; A signal which is fired whenever the wind lines effect stops. "},{"title":"Functions​","type":1,"pageTitle":"WindLines","url":"api/WindLines#functions","content":" "},{"title":"IsEffectStarted​","type":1,"pageTitle":"WindLines","url":"api/WindLines#IsEffectStarted","content":"&lt;/&gt; WindLines.IsEffectStarted() → boolean Returns a boolean indicating if the wind lines effect has started.  "},{"title":"IsStarted​","type":1,"pageTitle":"WindLines","url":"api/WindLines#IsStarted","content":"&lt;/&gt; WindLines.IsStarted() → boolean Returns a boolean indicating if WindLines, the module it self, is started through WindLines.Start.  "},{"title":"SetConfig​","type":1,"pageTitle":"WindLines","url":"api/WindLines#SetConfig","content":"&lt;/&gt; WindLines.SetConfig(newConfig: WindLinesConfig) → () Sets the current config of WindLines to newConfig, which means that this new config will be used for wind line effects. warning You cannot configure WindLines once it is started, so always make sure to call this method before you start WindLines!  "},{"title":"Start​","type":1,"pageTitle":"WindLines","url":"api/WindLines#Start","content":"&lt;/&gt; WindLines.Start() → () Starts up the wind lines effect. note If the player is standing under a roof, then the wind lines effect will be stopped for realism purposes and this behavior cannot be toggled. However, you can adjust this behavior through WindLines:SetConfig through the RaycastParams member, since ray casting is used in determining if the player is standing under a roof. E.g, the following config does not consider descendants in the badParts folder as roofs, so if a player stands under them, the wind lines effect will not be stopped: local WindLines = require(...) local badParts = ... -- a folder local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {badParts} WindLines.SetConfig({RaycastParams = raycastParams}) WindLines.Start()   "},{"title":"Stop​","type":1,"pageTitle":"WindLines","url":"api/WindLines#Stop","content":"&lt;/&gt; WindLines.Stop() → () Stops the wind lines effect. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#types","content":" "},{"title":"SignalConnection​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Disconnect: () → () Connected: boolean }  "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#new","content":"&lt;/&gt; RemoteSignal.new() → RemoteSignal Creates and returns a new remote signal.  "},{"title":"IsA​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#IsA","content":"&lt;/&gt; RemoteSignal.IsA(self: any) → boolean Returns a boolean indicating if self is a remote signal or not.  "},{"title":"ConnectOnce​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#ConnectOnce","content":"&lt;/&gt; RemoteSignal:ConnectOnce(callback: (...any) → ()) → SignalConnection Works almost exactly the same as RemoteSignal:ConnectOnce, except the connection returned is disconnected automaticaly once callback is called.  "},{"title":"Connect​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Connect","content":"&lt;/&gt; RemoteSignal:Connect(callback: (...any) → ()) → SignalConnection Connects callback to the remote signal so that it is called whenever the client fires the remote signal, and callback will be passed arguments sent by the client.  "},{"title":"FireForSpecificPlayers​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireForSpecificPlayers","content":"&lt;/&gt; RemoteSignal:FireForSpecificPlayers( players: {Player }, ...: any ) → () Fires the arguments ... to every player in the players table only.  "},{"title":"FireForPlayer​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireForPlayer","content":"&lt;/&gt; RemoteSignal:FireForPlayer( player: Player , ...: any ) → () Fires the arguments ... to player.  "},{"title":"FireForAll​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#FireForAll","content":"&lt;/&gt; RemoteSignal:FireForAll(...: any) → () Fires the arguments ... to every player in the game.  "},{"title":"DisconnectAll​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#DisconnectAll","content":"&lt;/&gt; RemoteSignal:DisconnectAll() → () Disconnects all connections connected via RemoteSignal:Connect or RemoteSignal:ConnectOnce.  "},{"title":"Destroy​","type":1,"pageTitle":"RemoteSignal","url":"api/RemoteSignal#Destroy","content":"&lt;/&gt; RemoteSignal:Destroy() → () Destroys the remote signal and renders it unusable. "},{"title":"Queue","type":0,"sectionRef":"#","url":"api/Queue","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Queue","url":"api/Queue#properties","content":" "},{"title":"Progressed​","type":1,"pageTitle":"Queue","url":"api/Queue#Progressed","content":"Signal Queue Instance &lt;/&gt; Queue.Progressed: Signal&lt;( callbackProgressed: () → (), deltaTime: number ) → ()&gt; A signal which is fired whenever the queue is progressed, i.e an appended callback is called. The callback called is passed as the first argument, and a second argument, deltaTime is also passed (which is basically how long (in seconds) it was before callbackProgressed was called ever since it was appended).  "},{"title":"Queue​","type":1,"pageTitle":"Queue","url":"api/Queue#Queue","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; Queue.Queue: Type An exported Luau type of a queue object. local Queue = require(...) local queue: Queue.Queue = Queue.new(...)  "},{"title":"Functions​","type":1,"pageTitle":"Queue","url":"api/Queue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Queue","url":"api/Queue#new","content":"&lt;/&gt; Queue.new() → Queue A constructor method which creates a new queue object.  "},{"title":"IsA​","type":1,"pageTitle":"Queue","url":"api/Queue#IsA","content":"&lt;/&gt; Queue.IsA(self: any) → boolean A method which returns a boolean indicating if self is a queue or not.  "},{"title":"EmptyQueue​","type":1,"pageTitle":"Queue","url":"api/Queue#EmptyQueue","content":"Queue Instance &lt;/&gt; Queue:EmptyQueue() → () Empties the queue, i.e all appended callbacks that are waiting to be resumed will never be resumed local Queue = require(...) local queue = Queue.new() local promise1 = queue:Append(function() task.wait(1) warn(&quot;called&quot;) --&gt; this never works, because the promise is cancelled as the queue is emptied! end) print(promise1:getStatus()) --&gt; &quot;Running&quot; (the promise is running) queue:EmptyQueue() print(promise1:getStatus()) --&gt; &quot;Cancelled&quot; (the promise has been cancelled now)   "},{"title":"Append​","type":1,"pageTitle":"Queue","url":"api/Queue#Append","content":"Queue Instance &lt;/&gt; Queue:Append(callback: (deltaTime: number) → ()) → Promise Appends callback to the queue so that it'll be called once the previous callbacks appended to the queue have finished running (or the promises associated to them have been cancelled). callback upon being called is passed a number as the only argument (the time it took for it to be called ever since it was appended). The method also returns a promise, which too resolves with a number (the time it took for callback to run ever since it was appended), once callback is called. tip The promise returned will be cancelled if EmptyQueue is called on the queue, but you can also manually just cancel the promise to effectively remove the added callback from the queue. local Queue = require(...) local queue = Queue.new() local promise1 = queue:Append(function(deltaTime) print(deltaTime) --&gt; 5.00003807246685e-07 task.wait(5) end) local promise2 = queue:Append(function(deltaTime) print(deltaTime) --&gt; 5.0113310999877285 task.wait(1) end) local promise2 = queue:Append(function(deltaTime) print(deltaTime) --&gt; 6.012134199991124 end)   "},{"title":"Destroy​","type":1,"pageTitle":"Queue","url":"api/Queue#Destroy","content":"Queue Instance &lt;/&gt; Queue:Destroy() → () Calls Queue:EmptyQueue and renders the queue unusable. "},{"title":"NetworkServer","type":0,"sectionRef":"#","url":"api/NetworkServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#types","content":" "},{"title":"Middleware​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#Middleware","content":"&lt;/&gt; interface Middleware { Inbound: {(args: {...any}) → ()}? Outbound: {(args: {...any}) → ()}? } Both Inbound and Outbound should be array of callbacks (if specified). Callbacks in Inbound are known as &quot;inbound callbacks&quot; and are called whenever a client tries to call a serverside method (exposed through the network object). The arguments sent by the client (to the method which they called) are packed into an array, which is then passed to each callback as the only argument. local inboundCallbacks = { function (arguments) print(arguments[1]:IsA(&quot;Player&quot;)) --&gt; true (first argument is always the client) arguments[2] = &quot;booooo&quot; --&gt; You can modify the arguments ! end } --- Automatic method call rejection If any inbound callback returns an explicit false value, then the method (which the client tried to call) will not be called. This is good, e.g for implementing queues! Callbacks in Outbound are known as &quot;outbound callbacks&quot; and are called whenever a serverside method (exposed through the network object) is called by the client, and has finished. The arguments sent by the client (to the method which they called) are packed into an array, which is then passed to each callback as the only argument. local outboundCallbacks = { function (arguments) print(arguments[1]:IsA(&quot;Player&quot;)) --&gt; true (first argument is always the client) end } --- Easy modification of the response sent to the client For outbound callbacks, an additional member in the arguments array, i.e MethodResponse is injected automatically, which is the response of the serverside method. This means you may feel free to modify the response of the serverside method before it is returned back to the client, e.g: -- Server: local Network = require(...) local middleware = { { function (arguments) arguments.MethodResponse = &quot;oops modified&quot; end } } local networkObject = Network.new(&quot;test&quot;, middleware) networkObject:Dispatch(workspace) -- Client: local Network = require(...) local networkObject = Network.FromName(&quot;test&quot;, workspace):expect() print(networkObject.SomeMethod()) --&gt; &quot;oops modified&quot;  "},{"title":"Functions​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#new","content":"&lt;/&gt; NetworkServer.new( name: string, middleware: Middleware? ) → NetworkServer Creates and returns a new network object of the name i.e name. Internally, a folder is created for each newly created network object, which too is named to name, but the folder it self is initially parented to nil so the network object isn't available to the client - call NetworkServer:Dispatch in order to render the network object accessible to the client.  "},{"title":"IsA​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#IsA","content":"&lt;/&gt; NetworkServer.IsA(self: any) → boolean Returns a boolean indicating if self is a network object or not.  "},{"title":"IsDispatchedToClient​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#IsDispatchedToClient","content":"&lt;/&gt; NetworkServer:IsDispatchedToClient() → boolean Returns a boolean indicating if the network object is dispatched to the client or not. note This method will always return false if the network object is destroyed.  "},{"title":"Append​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#Append","content":"&lt;/&gt; NetworkServer:Append( key: string, value: RemoteProperty | RemoteSignal | any ) → () Appends a key value pair, key and value, to the network object, so that it is available to the client once the network object is dispatched. E.g: -- Server local Network = require(...) local networkObject = Network.new(&quot;test&quot;) networkObject:Append(&quot;key&quot;, &quot;the value!&quot;) networkObject:Dispatch(workspace) -- Client local networkObject = Network.FromServer(&quot;test&quot;, workspace):expect() print(networkObject.key) --&gt; &quot;the value!&quot; note Argument limitations do apply since remote functions are internally used to replicate the appended key value pairs to the client. warning This method will error if the network object is dispatched to the client. Always make sure to append keys and valuesbefore you dispatch the network object. You can check if a network object is dispatched to the client or not through NetworkServer:IsDispatchedToClient.  "},{"title":"Dispatch​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#Dispatch","content":"&lt;/&gt; NetworkServer:Dispatch(parent: Instance ) → () Dispatches the network folder of the network object to parent, rendering the network object accessible to the client now. warning If another network object of the same name as this network object, is already dispatched to parent, then this method will error - you can't have more than 1 network object of the same name dispatched to the same instance!  "},{"title":"Destroy​","type":1,"pageTitle":"NetworkServer","url":"api/NetworkServer#Destroy","content":"&lt;/&gt; NetworkServer:Destroy() → () Destroys the network object and all appended remote properties / remote signals within the network object, and renders the network object useless. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"api/RemoteProperty","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#properties","content":" "},{"title":"Updated​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Updated","content":"This item is read only and cannot be modified. Read Only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.Updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the remote property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"PlayerValueUpdated​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#PlayerValueUpdated","content":"This item is read only and cannot be modified. Read Only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.PlayerValueUpdated: Signal&lt;player: Player, newValue: any&gt; A signal which is fired whenever the value of player specifically in the remote property is set to a new one. The signal is passed the player as the first argument, and the new specific value of player set in the remote property as the second argument. "},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#new","content":"&lt;/&gt; RemoteProperty.new(initialValue: any) → RemoteProperty Creates and returns a new remote property of the value initialValue.  "},{"title":"IsA​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#IsA","content":"&lt;/&gt; RemoteProperty.IsA(self: any) → boolean Returns a boolean indicating if self is a remote property or not.  "},{"title":"Get​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Get","content":"&lt;/&gt; RemoteProperty:Get() → any Returns the current value set for the remote property.  "},{"title":"SetForPlayer​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#SetForPlayer","content":"&lt;/&gt; RemoteProperty:SetForPlayer( player: Player , value: any ) → () Sets a value of the remote property for player specifically, to value.  "},{"title":"RemoveForPlayer​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#RemoveForPlayer","content":"&lt;/&gt; RemoteProperty:RemoveForPlayer(player: Player ) → () Removes the value stored for player specifically in the the remote property.  "},{"title":"HasPlayerSpecificValueSet​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#HasPlayerSpecificValueSet","content":"&lt;/&gt; RemoteProperty:HasPlayerSpecificValueSet(player: Player ) → boolean Returns a boolean indicating if there is a specific value stored for player in the remote property.  "},{"title":"GetForPlayer​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#GetForPlayer","content":"&lt;/&gt; RemoteProperty:GetForPlayer(player: Player ) → any Returns the value stored specifically for player in the remote property.  "},{"title":"Set​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Set","content":"&lt;/&gt; RemoteProperty:Set(value: any) → () Sets the value of the remote property to value, and so for all other clients (who can access this value through a client remote property), who don't have a specific value for them stored in the remote property.  "},{"title":"Destroy​","type":1,"pageTitle":"RemoteProperty","url":"api/RemoteProperty#Destroy","content":"&lt;/&gt; RemoteProperty:Destroy() → () Destroys the remote property and renders it unusable. "},{"title":"InstanceUtil","type":0,"sectionRef":"#","url":"api/InstanceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#functions","content":" "},{"title":"SetInstanceProperties​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#SetInstanceProperties","content":"&lt;/&gt; InstanceUtil.SetInstanceProperties( instance: Instance , properties: {[string]: any} ) → () Sets the properties of instance from the properties table. local InstanceUtil = require(...) InstanceUtil.SetInstanceProperties(workspace.Baseplate, {Transparency = 1}) print(workspace.Baseplate.Transparency) --&gt; 1   "},{"title":"SetInstanceAttributes​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#SetInstanceAttributes","content":"&lt;/&gt; InstanceUtil.SetInstanceAttributes( instance: Instance , attributes: {[string]: any} ) → () Sets all the keys and values in attributes table as attributes of instance. local InstanceUtil = require(...) InstanceUtil.SetInstanceAttributes(workspace.Baseplate, {IsMayoSauce = true}) print(workspace.Baseplate:GetAttribute(&quot;IsMayoSauce&quot;)) --&gt; true   "},{"title":"SetInstancePhysicsCollisionGroup​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#SetInstancePhysicsCollisionGroup","content":"&lt;/&gt; InstanceUtil.SetInstancePhysicsCollisionGroup( instance: Instance , collisionGroup: string ) → () Sets the collision group of instance to collisionGroup, if it is a BasePart. Else,all the descendants of instance (BasePart's) will have their collision group set to collisionGroup.  "},{"title":"ResetInstancePhysicsCollisionGroup​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#ResetInstancePhysicsCollisionGroup","content":"&lt;/&gt; InstanceUtil.ResetInstancePhysicsCollisionGroup(instance: Instance ) → () Sets the collision group of instance to the default collision group i.e &quot;Default&quot;, if it is a BasePart. Else, all the descendants of instance (BasePart's) will have their collision group set to &quot;Default&quot;.  "},{"title":"SetInstancePhysicalProperties​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#SetInstancePhysicalProperties","content":"&lt;/&gt; InstanceUtil.SetInstancePhysicalProperties( instance: Instance , physicalProperties: { Density: number?, Friction: number?, Elasticity: number?, FrictionWeight: number?, ElasticityWeight: number?, } ) → () Sets the PhysicalProperties of instance to match the physicalProperties table, if it is a BasePart. Else, all the descendants of instance (BasePart's) will have their PhysicalProperties set to match the physicalProperties table local physicalProperties = { Density = 1 } InstanceUtil.SetInstancePhysicalProperties(workspace.Baseplate, physicalProperties)   "},{"title":"ResetInstancePhysicalProperties​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#ResetInstancePhysicalProperties","content":"&lt;/&gt; InstanceUtil.ResetInstancePhysicalProperties(instance: Instance ) → () Sets the PhysicalProperties of instance to the default, if it is a BasePart. Else, all the descendants of instance (BasePart's) will have their PhysicalProperties set to the default.  "},{"title":"GetInstanceCorners​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#GetInstanceCorners","content":"&lt;/&gt; InstanceUtil.GetInstanceCorners(instance: Instance ) → { Top: {Vector3 }, Bottom: {Vector3 } } Returns a read only dictionary of all corners of instance, top and bottom.  "},{"title":"GetInstanceFloorMaterial​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#GetInstanceFloorMaterial","content":"&lt;/&gt; InstanceUtil.GetInstanceFloorMaterial( instance: BasePart , raycastParams: RaycastParams?, depth: number? ) → EnumItem  Returns the material the instance is lying on. The 2nd argument can be passed as a RaycastParams object, which will be used in determining the material of instance through ray casting. The 3rd argument can be passed as a number (depth) which will increase the length of the ray by depth studs (on the Y axis). This is only useful when you want to add in more leeway in determining the material of instance reliably, since sometimes the instance may be very slightly over the top of some ground due to it's geometr so in those cases, the ray may not register properly. If this argument isn't specified, then it will default to 0.01.   "},{"title":"SetInstanceNetworkOwner​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#SetInstanceNetworkOwner","content":"&lt;/&gt; InstanceUtil.SetInstanceNetworkOwner( instance: BasePart , networkOwner: Player? ) → () Sets the network owner of instance to networkOwner safely. tip This method will safely return nil instead of erroring, if the network ownership API can't be used on instance. Hence this method should be preferred over directly setting the network owner of instance via SetNetworkOwner,  "},{"title":"GetInstanceNetworkOwner​","type":1,"pageTitle":"InstanceUtil","url":"api/InstanceUtil#GetInstanceNetworkOwner","content":"&lt;/&gt; InstanceUtil.GetInstanceNetworkOwner(instance: BasePart ) → Player?  Returns the network owner of instance safely. tip This method will safely return nil instead of erroring, if the network ownership API can't be used on instance . Hence this method should be preferred over directly getting the network owner of instance via GetNetworkOwner. "},{"title":"Property","type":0,"sectionRef":"#","url":"api/Property","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"Property","url":"api/Property#properties","content":" "},{"title":"Updated​","type":1,"pageTitle":"Property","url":"api/Property#Updated","content":"This item is read only and cannot be modified. Read Only Signal Property Instance &lt;/&gt; Property.Updated: Signal&lt;newValue: any&gt; A signal which is fired whenever the value of the property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"Property​","type":1,"pageTitle":"Property","url":"api/Property#Property","content":"This item is read only and cannot be modified. Read Only Luau Type &lt;/&gt; Property.Property: Type An exported Luau type of a property object. local Property = require(...) local property: Property.Property = Property.new(...)  "},{"title":"Functions​","type":1,"pageTitle":"Property","url":"api/Property#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Property","url":"api/Property#new","content":"&lt;/&gt; Property.new(initialValue: any) → Property A constructor method which creates a new property object, with initialValue as the current value of the property.  "},{"title":"IsA​","type":1,"pageTitle":"Property","url":"api/Property#IsA","content":"&lt;/&gt; Property.IsA(self: any) → boolean A method which returns a boolean indicating if self is a property or not.  "},{"title":"Set​","type":1,"pageTitle":"Property","url":"api/Property#Set","content":"Property Instance &lt;/&gt; Property:Set(value: any) → () Sets the value of the property to value, if this new value isn't the same as the previous value.  "},{"title":"DeferredSet​","type":1,"pageTitle":"Property","url":"api/Property#DeferredSet","content":"Property Instance &lt;/&gt; Property:DeferredSet(value: any) → () Works exactly the same as Property.Set, except the updating of the property's value to value is deferred through task.defer.  "},{"title":"ForceSet​","type":1,"pageTitle":"Property","url":"api/Property#ForceSet","content":"Property Instance &lt;/&gt; Property:ForceSet(value: any) → () Works exactly the same as Property.Set except that tables aren't checked for equality, e.g: local Property = require(...) local property = Property.new() property.Updated:Connect(function(newVal) warn(newVal) --&gt; {1} end) local t = {1} property:ForceSet(t) --&gt; Fires off the .Updated signal (expected) property:ForceSet(t) --&gt; Fires off the .Updated signal (this ought to not fire off the signal, but the previous and new value aren't checked for equality since they're both tables) property:ForceSet(1) --&gt; Fires off the .Updated signal (expected as a number ~= table) property:ForceSet(1) --&gt; DOES NOT fire off the .Updated signal, since the previous value (a number, not a table) and the new value (a number, not a table) are the same!   "},{"title":"BulkSet​","type":1,"pageTitle":"Property","url":"api/Property#BulkSet","content":"Property Instance &lt;/&gt; Property:BulkSet(value: any) → () Works almost exactly the same as Property:Set, but never fires off the Property.Updated signal.  "},{"title":"Get​","type":1,"pageTitle":"Property","url":"api/Property#Get","content":"Property Instance &lt;/&gt; Property:Get() → any Returns the current value of the property. local Property = require(...) local property = Property.new() property:Set(5) print(property:Get()) --&gt; 5   "},{"title":"Destroy​","type":1,"pageTitle":"Property","url":"api/Property#Destroy","content":"Property Instance &lt;/&gt; Property:Destroy() → () Destroys the property and renders it unusable. "},{"title":"EnumList","type":0,"sectionRef":"#","url":"api/EnumList","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"EnumList","url":"api/EnumList#functions","content":" "},{"title":"new​","type":1,"pageTitle":"EnumList","url":"api/EnumList#new","content":"&lt;/&gt; EnumList.new( name: string, enums: {[string]: {[string]: any}} ) → EnumList A constructor method which creates a new enum list out of enumItems, and with name name. local EnumList = require(...) local enumList = EnumList.new(&quot;Enums&quot;, {Test = 123}) print(enumList.Test) --&gt; 123   "},{"title":"IsA​","type":1,"pageTitle":"EnumList","url":"api/EnumList#IsA","content":"&lt;/&gt; EnumList.IsA(self: any) → boolean A method which returns a boolean indicating if self is a enumlist or not.  "},{"title":"GetEnums​","type":1,"pageTitle":"EnumList","url":"api/EnumList#GetEnums","content":"&lt;/&gt; EnumList:GetEnums() → {[string]: CustomEnum} Returns the enums of the enum list. "},{"title":"NumberUtil","type":0,"sectionRef":"#","url":"api/NumberUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#properties","content":" "},{"title":"e​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#e","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.e: number Also known as Euler's number. This is a mathematical constant approximately equal to approximately 2.7182818284590.  "},{"title":"Phi​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Phi","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.Phi: number Also known as the golden ratio, equal to approximately 1.618033988749895.  "},{"title":"Tau​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Tau","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; NumberUtil.Tau: number It is the circle constant representing the ratio between circumference and radius and is equal to (2 times pi), so approximately 6.28. "},{"title":"Functions​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#functions","content":" "},{"title":"Lerp​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Lerp","content":"&lt;/&gt; NumberUtil.Lerp( number: number, goal: number, alpha: number ) → number Interpolates number to goal, with alpha being the multiplier. local NumberUtil = require(...) local num = 2 local goal = 5 num = NumberUtil.Lerp(num, goal, 0.7) print(num) --&gt; 4.1   "},{"title":"QuadraticLerp​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#QuadraticLerp","content":"&lt;/&gt; NumberUtil.QuadraticLerp( number: number, goal: number, alpha: number ) → number Quadraticly interpolates number to goal, with alpha being the multiplier. local NumberUtil = require(...) local num = 2 local goal = 5 num = NumberUtil.QuadraticLerp(num, goal, 0.7) print(num) --&gt; 4.1   "},{"title":"InverseLerp​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#InverseLerp","content":"&lt;/&gt; NumberUtil.InverseLerp( min: number, max: number, alpha: number ) → number Inverse Lerp is the inverse operation of the Lerp Node. It can be used to determine what the input to a Lerp was based on its output. For e.g, the value of a Lerp between 0 and 2 with alpha being 1 is 0.5. Therefore the value of an Inverse Lerp between 0 and 2 with alpha being 0.5 is 1. local NumberUtil = require(...) local num = 2 local goal = 5 num = NumberUtil.InverseLerp(num, goal, 0.7) print(num) --&gt; -0.43333333333333335   "},{"title":"Map​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Map","content":"&lt;/&gt; NumberUtil.Map( number: number, inMin: number, inMax: number, outMin: number, outMax: number ) → number Maps number between inMin and inMax, and outMin and outMax. local NumberUtil = require(...) print(NumberUtil.Map(1,2,3,4,5)) --&gt; 3   "},{"title":"IsNaN​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#IsNaN","content":"&lt;/&gt; NumberUtil.IsNaN(number: number) → boolean Returns a boolean indicating if number is NaN (Not A Number). local NumberUtil = require(...) print(NumberUtil.IsNan(0 / 0)) --&gt; true   "},{"title":"AreClose​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#AreClose","content":"&lt;/&gt; NumberUtil.AreClose( number: number, to: number, eplison: number? ) → boolean Returns a boolean indicating if the difference between number and to is lower than or equal to eplsion. local NumberUtil = require(...) print(NumberUtil.AreClose(0.1 + 0.2, 0.3)) --&gt; true print(NumberUtil.AreClose(0.1 + 0.2, 0.3, 0)) --&gt; false If eplison is not specified, then it will default to 1e-5.  "},{"title":"Root​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Root","content":"&lt;/&gt; NumberUtil.Root( number: number, root: number ) → number Returns the root of number. local NumberUtil = require(...) print(NumberUtil.Root(2, 3)) --&gt; 1.2599210498948732 (same as cube root of 2) print(NumberUtil.Root(2, 2)) --&gt; 1.4142135623730951 (same as square root of 2)   "},{"title":"Factorial​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Factorial","content":"&lt;/&gt; NumberUtil.Factorial(number: number) → number Returns the factorial of number. local NumberUtil = require(...) print(NumberUtil.Factorial(3)) --&gt; 6   "},{"title":"Factors​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#Factors","content":"&lt;/&gt; NumberUtil.Factors(number: number) → {number} Returns an array of all factors of number. local NumberUtil = require(...) print(NumberUtil.Factors(2)) --&gt; {1, 2}   "},{"title":"IsInfinite​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#IsInfinite","content":"&lt;/&gt; NumberUtil.IsInfinite(number: number) → boolean Returns a boolean indicating if number is infinite. local NumberUtil = require(...) print(NumberUtil.IsInfinite(math.huge)) --&gt; true   "},{"title":"ClampTo​","type":1,"pageTitle":"NumberUtil","url":"api/NumberUtil#ClampTo","content":"&lt;/&gt; NumberUtil.ClampTo( number: number, min: number, max: number, clamp: number ) → number Clamps number to clamp, if number is greater than max or lower than min. local NumberUtil = require(...) print(NumberUtil.ClampTo(1, 2, 5, 150)) --&gt; 150  "}]