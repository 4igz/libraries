"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8093],{16593:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"A constructor method which creates a new queue object.","params":[],"returns":[{"desc":"","lua_type":"Queue"}],"function_type":"static","source":{"line":59,"path":"src/Queue/init.lua"}},{"name":"is","desc":"A method which returns a boolean indicating if `self` is a queue or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":70,"path":"src/Queue/init.lua"}},{"name":"emptyQueue","desc":"Empties the queue, i.e all appended callbacks that are waiting to be resumed \\nwill never be resumed\\n\\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nlocal promise1 = queue:append(function()\\n\\ttask.wait(1)\\n\\twarn(\\"called\\") --\x3e this never works, because the promise is cancelled\\n\\t-- as the queue is emptied! \\nend)\\n\\nprint(promise1:getStatus()) --\x3e \\"Running\\" (the promise is running)\\nqueue:emptyQueue() \\nprint(promise1:getStatus()) --\x3e \\"Cancelled\\"  (the promise has been cancelled)\\n```","params":[],"returns":[],"function_type":"method","tags":["Queue Instance"],"source":{"line":97,"path":"src/Queue/init.lua"}},{"name":"append","desc":"Appends `callback` to the queue so that it\'ll be called once the previous \\ncallbacks appended to the queue have *finished* running (or the promises \\nassociated to them have been cancelled). `callback` upon being called is \\npassed a number as the only argument (the time it took for it to be called \\never since it was appended). \\n\\nThe method also returns a promise, which too resolves with a number \\n(the time it took for `callback` to run ever since it was appended),  \\nonce `callback` is called.\\n\\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nlocal promise1 = queue:append(function(deltaTime)\\n\\tprint(deltaTime) --\x3e 5.00003807246685e-07 \\n\\ttask.wait(5)\\nend)\\n\\nlocal promise2 = queue:append(function(deltaTime) \\n\\tprint(deltaTime) --\x3e 5.0113310999877285\\n\\ttask.wait(1)\\nend)\\n\\nlocal promise2 = queue:append(function(deltaTime) \\n\\tprint(deltaTime) --\x3e 6.012134199991124 \\nend)\\n```\\n\\n:::tip\\nThe promise returned will be cancelled if [Queue:EmptyQueue] is called, but \\nyou can also manually  just cancel the promise to effectively remove the \\nadded callback from the queue, e.g:\\n\\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nlocal promise = queue:append(function(deltaTime) \\n\\tprint(deltaTime) --\x3e never prints!\\nend)\\n\\npromise:cancel() --\x3e Cancel the promise!\\n```\\n:::","params":[{"name":"callback","desc":"","lua_type":"(deltaTime: number) -> ()"}],"returns":[{"desc":"","lua_type":"Promise <deltaTime: number>"}],"function_type":"method","tags":["Queue Instance"],"source":{"line":158,"path":"src/Queue/init.lua"}},{"name":"destroy","desc":"Calls [Queue:EmptyQueue] and renders the queue unusable.","params":[],"returns":[],"function_type":"method","tags":["Queue Instance"],"source":{"line":194,"path":"src/Queue/init.lua"}}],"properties":[{"name":"progressed","desc":" \\n\\nA [signal](https://sleitnick.github.io/RbxUtil/api/Signal/) which is fired \\nwhenever the queue is progressed, i.e an appended callback is called. The callback \\ncalled is passed as the first argument, and a second argument, `deltaTime` is also \\npassed (which is basically how long (in seconds) it was before `callbackProgressed` \\nwas called ever since it was appended).","lua_type":"Signal <callbackProgressed: () -> (), deltaTime: number>","tags":["Signal","Queue Instance"],"source":{"line":37,"path":"src/Queue/init.lua"}},{"name":"queue","desc":" \\n\\nAn exported Luau type of a queue object.","lua_type":"Type","tags":["Luau Type"],"readonly":true,"source":{"line":46,"path":"src/Queue/init.lua"}}],"types":[],"name":"Queue","desc":" \\n\\nA class for creating queues. A queue in layman\'s term, is simply an to which\\nyou can append callbacks to, which will run based on when they\'re added, i.e \\nthey **follow** the *FIFO (First In, First Out) pattern* .\\n \\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nfor i = 1, 3 do \\n\\tqueue:append(function(deltaTime)\\n\\t\\twarn((\\"completed task (%d) in %s seconds.\\"):format(task.wait(i), deltaTime))\\n\\tend)\\nend\\n\\n--\x3e \\"completed task (1)\\" \\n--\x3e \\"completed task (2)\\"\\n--\x3e \\"completed task (3)\\"\\n```","source":{"line":24,"path":"src/Queue/init.lua"}}')}}]);