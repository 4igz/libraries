"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9927],{9879:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new network object of the name i.e `name`. \\n\\nInternally, a folder is created for each newly created network object, which too is named to `name`, \\nbut the folder it self is initially parented to `nil` so the network object isn\'t available to the\\nclient - call [NetworkServer:Dispatch] in order to render the network object accessible to the client.","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"middleware","desc":"","lua_type":"Middleware?"}],"returns":[{"desc":"","lua_type":"NetworkServer"}],"function_type":"static","source":{"line":108,"path":"src/Network/Server/init.lua"}},{"name":"IsA","desc":"Returns a boolean indicating if `self` is a network object or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":132,"path":"src/Network/Server/init.lua"}},{"name":"IsDispatchedToClient","desc":"Returns a boolean indicating if the network object is dispatched to the client or not. \\n\\n:::note\\nThis method will always return false if the network object is destroyed.\\n:::","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":144,"path":"src/Network/Server/init.lua"}},{"name":"Append","desc":"Appends a key value pair, `key` and `value`, to the network object, so that it is available to the client\\nonce the network object is dispatched. E.g:\\n\\n```lua\\n-- Server\\nlocal Network = require(...)\\n\\nlocal networkObject = Network.new(\\"test\\")\\nnetworkObject:Append(\\"key\\", \\"the value!\\")\\nnetworkObject:Dispatch(workspace)\\n\\n-- Client\\nlocal networkObject = Network.FromServer(\\"test\\", workspace):expect()\\nprint(networkObject.key) --\x3e \\"the value!\\"\\n```\\n\\t\\n:::note\\n[Argument limitations](https://create.roblox.com/docs/scripting/events/argument-limitations-for-bindables-and-remotes)\\ndo apply since remote functions are internally used to replicate the appended key value pairs to the client.\\n:::\\n\\n:::warning\\nThis method will error if the network object is dispatched to the client. Always make sure to append keys and values\\n*before* you dispatch the network object. You can check if a network object is dispatched to the client or not through\\n[NetworkServer:IsDispatchedToClient].\\n:::","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"RemoteProperty | RemoteSignal | any"}],"returns":[],"function_type":"method","source":{"line":179,"path":"src/Network/Server/init.lua"}},{"name":"Dispatch","desc":"Dispatches the network folder of the network object to `parent`, rendering the network object accessible\\nto the client now.\\n\\n:::warning\\nIf another network object of the same name as this network object, is already dispatched to `parent`, then this\\nmethod will error - you can\'t have more than 1 network object of the same name dispatched to the same instance!\\n:::","params":[{"name":"parent","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":199,"path":"src/Network/Server/init.lua"}},{"name":"Destroy","desc":"Destroys the network object and all appended remote properties / remote signals within the network object, and renders\\nthe network object useless. ","params":[],"returns":[],"function_type":"method","source":{"line":213,"path":"src/Network/Server/init.lua"}}],"properties":[],"types":[{"name":"Middleware","desc":"Both `Inbound` and `Outbound` should be array of callbacks (if specified). Callbacks in `Inbound` are\\nknown as \\"inbound callbacks\\" and are called whenever a client tries to call a serverside method \\n(exposed through the network object). The arguments sent by the client (to the method which they called)\\nare packed into an array, which is then passed to each callback as the only argument. \\n\\n```lua\\nlocal inboundCallbacks = {\\n\\tfunction (arguments)\\n\\t\\tprint(arguments[1]:IsA(\\"Player\\")) --\x3e true (first argument is always the client)\\n\\t\\targuments[2] = \\"booooo\\" --\x3e You can modify the arguments !\\n\\tend\\n}\\n---\\n```\\n\\n:::tip Automatic method call rejection\\nIf any inbound callback returns an **explicit** false value, then the method (which the client tried to call) will *not* be\\ncalled. This is good, e.g for implementing queues via middlewares!\\n:::\\n\\nCallbacks in `Outbound` are known as \\"outbound callbacks\\" and are called whenever a serverside method \\n(exposed through the network object) is called by the client, and has **finished**. The arguments sent \\nby the client (to the method which they called) are packed into an array, which is then passed \\nto each callback as the only argument. \\n\\n```lua\\nlocal outboundCallbacks = {\\n\\tfunction (arguments)\\n\\t\\tprint(arguments[1]:IsA(\\"Player\\")) --\x3e true (first argument is always the client)\\n\\tend\\n}\\n---\\n```\\n\\n:::tip Easy modification of the response sent to the client\\nFor outbound callbacks, an additional member in the arguments array, i.e `MethodResponse` is injected automatically, which is \\nthe response of the serverside method. This means you may feel free to modify the response of the serverside method\\nbefore it is returned back to the client, e.g:\\n\\n```lua\\nlocal outboundCallbacks = {\\n\\tfunction (arguments)\\n\\t\\targuments.MethodResponse = \\"oops modified\\" \\n\\tend\\n}\\n\\n-- Client:\\nlocal response = networkObject.SomeMethod()\\nprint(response) --\x3e \\"oops modified\\"\\n```\\n:::","fields":[{"name":"Inbound","lua_type":"{(args: {...any}) -> ()}?","desc":""},{"name":"Outbound","lua_type":"{(args: {...any}) -> ()}?","desc":""}],"source":{"line":65,"path":"src/Network/Server/init.lua"}}],"name":"NetworkServer","desc":"The server counterpart of the Network module.","source":{"line":6,"path":"src/Network/Server/init.lua"}}')}}]);