"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4629],{54832:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new network object of the name i.e `name`. \\n\\n:::note\\nThe network object will initially not be available to the client, you need to call [NetworkServer:dispatch] \\nin order to render the network object accessible to the client!\\n:::","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"middleware","desc":"","lua_type":"Middleware?"}],"returns":[{"desc":"","lua_type":"NetworkServer"}],"function_type":"static","source":{"line":255,"path":"src/network/Server/init.lua"}},{"name":"is","desc":"Returns a boolean indicating if `self` is a network object or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":279,"path":"src/network/Server/init.lua"}},{"name":"isDispatched","desc":"Returns a boolean indicating if the network object is dispatched to the \\nclient or not. \\n\\n:::note\\nThis method will always return false if the network object is destroyed.\\n:::","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":292,"path":"src/network/Server/init.lua"}},{"name":"append","desc":"Appends a key value pair, `key` and `value`, to the network object, so that\\nit is available to the client once the network object is dispatched. \\n\\nFor e.g:\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal TestNetwork = Network.Server.new(\\"test\\")\\nTestNetwork:append(\\"key\\", \\"the value!\\")\\nTestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal testNetwork = Network.client.fromParent(\\"test\\", Workspace):expect()\\nprint(testNetwork.key) --\x3e \\"the value!\\"\\n```\\n\\n:::tip\\nYou can also append a [RemoteSignal] and a [RemoteProperty] as well!\\n:::\\t\\n\\n:::note\\n[Argument limitations](https://create.roblox.com/docs/scripting/events/argument-limitations-for-bindables-and-remotes)\\napply, as remote functions are internally used the key value pairs accessible to the clients.\\n:::\\n\\n:::warning\\nThis method will error if the network object is dispatched to the client. \\nAlways make sure to append keys and values *before* you dispatch the \\nnetwork object. You can check if a network object is dispatched to the \\nclient or not through [NetworkServer:dispatched].\\n:::","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":334,"path":"src/network/Server/init.lua"}},{"name":"dispatch","desc":"Dispatches the network folder of the network object to `parent`, rendering\\nthe network object accessible to the client now.\\n\\n:::warning\\nIf another network object of the same name as this network object, is already\\ndispatched to `parent`, then this method will error - you can\'t have more than \\n1 network object of the same name dispatched to the same instance!\\n:::","params":[{"name":"parent","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":352,"path":"src/network/Server/init.lua"}},{"name":"destroy","desc":"Destroys the network object and all appended remote properties &\\nremote signals within the network object, and renders the network \\nobject useless. ","params":[],"returns":[],"function_type":"method","source":{"line":365,"path":"src/network/Server/init.lua"}}],"properties":[{"name":"RemoteProperty","desc":" \\n\\nA reference to the [RemoteProperty] module.","lua_type":"RemoteProperty","readonly":true,"source":{"line":15,"path":"src/network/Server/init.lua"}},{"name":"RemoteProperty","desc":" \\n\\nA reference to the [RemoteSignal] module.","lua_type":"RemoteSignal","readonly":true,"source":{"line":23,"path":"src/network/Server/init.lua"}},{"name":"NetworkServer","desc":" \\n\\nAn exported Luau type of a network object.","lua_type":"Type","readonly":true,"source":{"line":31,"path":"src/network/Server/init.lua"}}],"types":[{"name":"Middleware","desc":"Both `methodCallInbound` and `methodCallOutbound` must be array of callbacks (if specified). \\n\\n### `methodCallInbound` \\n\\nCallbacks in `methodCallInbound` are called whenever a client tries to call any of the appended methods of the network. \\n\\nThe first argument passed to each callback is the name of the method (the client called), and the second argument, i.e \\nthe arguments sent by the client, which are are packed into an array. \\n\\n```lua\\nlocal methodCallInboundCallbacks = {\\n\\tfunction (methodName, arguments)\\n\\t\\tprint(arguments[1]:IsA(\\"Player\\")) --\x3e true (the first argument is always the client)\\n\\t\\tprint(typeof(arguments)) --\x3e \\"table\\"\\n\\tend\\n}\\n---\\n```\\n\\n:::tip \\n- If any of the callbacks return an **explicit** false value, then the method which the client tried to call, will *not* be\\ncalled. This is useful as you can implement for e.g, implementing rate limits!\\n\\n- Additionally, you can modify the `arguments` table which will be reflected to the method, for e.g:\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal TestNetwork = Network.Server.new(\\"Test\\", {methodCallInbound = {\\n\\tfunction(_, arguments) arguments[2] = \\"test\\" end\\n}})\\nTestNetwork:append(\\"method\\", function(player, a)\\n\\tprint(a) --\x3e \\"test\\" (a ought to be 1, but the middleware modified it!)\\nend)\\nTestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal testNetwork = network.client.fromParent(\\"Test\\", Workspace)\\nestNetwork.method(1) \\n```\\n:::\\n\\n### `methodCallOutbound` \\n\\nCallbacks in `methodCallOutbound` are called whenever a method (appended to the network) is called by the client, and \\nhas **finished** running.  \\n\\nThe first argument passed to each callback is the name of the method (client called), and the second argument, i.e \\nthe arguments sent by the client, which are are packed into an array. \\n\\n```lua\\nlocal methodCallOutboundCallbacks = {\\n\\tfunction (methodName, arguments)\\n\\t\\tprint(arguments[1]:IsA(\\"Player\\")) --\x3e true (the first argument is always the client)\\n\\t\\tprint(typeof(arguments)) --\x3e \\"table\\"\\n\\tend\\n}\\n---\\n```\\n\\n:::tip \\nA third argument i.e `response` is passed to each callback as well, which is just the response of the method called. For e.g:\\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n\\tmethodCallOutbound = {\\n\\t\\t{\\n\\t\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\t\\tprint(response) --\x3e \\"this\\"\\n\\t\\t\\t\\treturn \\"oops modified\\"\\n\\t\\t\\tend\\n\\t\\t}\\n\\t}\\n}\\n\\nlocal Network = network.Server.new(\\"test\\", middleware)\\nNetwork:append(\\"SomeMethod\\", function()\\n\\treturn \\"this\\"\\nend)\\nNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"test\\", Workspace):expect()\\nprint(testNetwork.SomeMethod()) --\x3e \\"oops modified\\" (ought to be \\"this\\" instead but modified by a middleware!)\\n```\\n\\nAdditionally, these callbacks can return a value which\'ll override the actual result of the method (which will be sent\\nback to the client). For e.g:\\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n\\t{\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\tprint(response) --\x3e \\"this\\"\\n\\t\\t\\treturn 50\\n\\t\\tend\\n\\t}\\n}\\n\\nlocal TestNetwork = network.Server.new(\\"test\\", middleware)\\nTestNetwork:append(\\"SomeMethod\\", function()\\n\\treturn \\"this\\"\\nend)\\nTestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.fromParent(\\"test\\", Workspace):expect()\\nprint(testNetwork.SomeMethod()) --\x3e 50 \\n```\\n\\nAdditionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and *then* sent\\nback to the client. This is by design - as it isn\'t really ideal to disregard all returned values for just 1.\\n\\nFor e.g: \\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n\\t{\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\treturn 1\\n\\t\\tend,\\n\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\treturn 2\\n\\t\\tend,\\n\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\treturn 3\\n\\t\\tend\\n\\t}\\n}\\n\\nlocal TestNetwork = network.server.new(\\"test\\", middleware)\\nTestNetwork:append(\\"someMethod\\", function()\\n\\treturn \\"this\\"\\nend)\\nTestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"test\\", Workspace):expect()\\nprint(testNetwork.someMethod()) --\x3e {1, 2, 3} \\n```\\n:::","fields":[{"name":"methodCallInbound","lua_type":"{ (methodName: string, args: {any} ) -> boolean}?","desc":""},{"name":"methodCallOutbound","lua_type":"{(methodName: string, args: {any}) -> any}?","desc":""}],"source":{"line":198,"path":"src/network/Server/init.lua"}}],"name":"NetworkServer","desc":"The server counterpart of the Network module.","realm":["Server"],"source":{"line":7,"path":"src/network/Server/init.lua"}}')}}]);