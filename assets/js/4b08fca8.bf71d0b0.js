"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8093],{16593:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"A constructor method which creates a new queue object.","params":[],"returns":[{"desc":"","lua_type":"Queue"}],"function_type":"static","source":{"line":62,"path":"src/Queue/init.lua"}},{"name":"IsA","desc":"A method which returns a boolean indicating if `self` is a queue or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":73,"path":"src/Queue/init.lua"}},{"name":"EmptyQueue","desc":"Empties the queue, i.e all appended callbacks that are waiting to be resumed will never be resumed\\n\\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nlocal promise1 = queue:Append(function()\\n\\ttask.wait(1)\\n\\twarn(\\"called\\") --\x3e this never works, because the promise is cancelled as the queue is emptied! \\nend)\\n\\nprint(promise1:getStatus()) --\x3e \\"Running\\" (the promise is running)\\nqueue:EmptyQueue() \\nprint(promise1:getStatus()) --\x3e \\"Cancelled\\"  (the promise has been cancelled now)\\n```","params":[],"returns":[],"function_type":"method","tags":["Queue Instance"],"source":{"line":98,"path":"src/Queue/init.lua"}},{"name":"Append","desc":"Appends `callback` to the queue so that it\'ll be called once the previous callbacks appended to the queue\\nhave *finished* running (or the promises associated to them have been cancelled). `callback` upon being called is passed \\na number as the only argument (the time it took for it to be called ever since it was appended). \\n\\nThe method also returns a promise, which too resolves with a number (the time it took for `callback` \\nto run ever since it was appended), once `callback` is called.\\n\\n:::tip\\nThe promise returned will be cancelled if `EmptyQueue` is called on the queue, but you can also manually \\njust cancel the promise to effectively remove the added callback from the queue.\\n:::\\n\\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nlocal promise1 = queue:Append(function(deltaTime)\\n\\tprint(deltaTime) --\x3e 5.00003807246685e-07 \\n\\ttask.wait(5)\\nend)\\n\\nlocal promise2 = queue:Append(function(deltaTime) \\n\\tprint(deltaTime) --\x3e 5.0113310999877285\\n\\ttask.wait(1)\\nend)\\n\\nlocal promise2 = queue:Append(function(deltaTime) \\n\\tprint(deltaTime) --\x3e 6.012134199991124 \\nend)\\n```","params":[{"name":"callback","desc":"","lua_type":"(deltaTime: number) -> ()"}],"returns":[{"desc":"","lua_type":"Promise <deltaTime: number>"}],"function_type":"method","tags":["Queue Instance"],"source":{"line":143,"path":"src/Queue/init.lua"}},{"name":"Destroy","desc":"Calls [Queue:EmptyQueue] and renders the queue unusable.","params":[],"returns":[],"function_type":"method","tags":["Queue Instance"],"source":{"line":176,"path":"src/Queue/init.lua"}}],"properties":[{"name":"Progressed","desc":" \\n\\nA [signal](https://sleitnick.github.io/RbxUtil/api/Signal/) which is fired whenever the queue is progressed, i.e an appended callback is called. The callback called\\nis passed as the first argument, and a second argument, `deltaTime` is also passed (which is basically how long (in seconds) it was before `callbackProgressed` was called\\never since it was appended).","lua_type":"Signal <(callbackProgressed: () -> (), deltaTime: number) -> ()>","tags":["Signal","Queue Instance"],"source":{"line":34,"path":"src/Queue/init.lua"}},{"name":"Queue","desc":" \\n\\nAn exported Luau type of a queue object.\\n\\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue: Queue.Queue = Queue.new(...) \\n```","lua_type":"Type","tags":["Luau Type"],"readonly":true,"source":{"line":49,"path":"src/Queue/init.lua"}}],"types":[],"name":"Queue","desc":" \\n\\nA simple class for creating queues. A queue in layman\'s term, is simply an to which you can append callbacks to, which\\nwill run based on when they\'re added, i.e they **follow** the *FIFO (First In, First Out) pattern* .\\n \\n```lua\\nlocal Queue = require(...)\\n\\nlocal queue = Queue.new()\\n\\nfor i = 1, 3 do \\n\\tqueue:Append(function(deltaTime)\\n\\t\\twarn((\\"completed task (%d) in %s seconds.\\"):format(task.wait(i), deltaTime))\\n\\tend)\\nend\\n\\n--\x3e \\"completed task (1)\\" \\n--\x3e \\"completed task (2)\\"\\n--\x3e \\"completed task (3)\\"\\n```","source":{"line":23,"path":"src/Queue/init.lua"}}')}}]);