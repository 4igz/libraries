"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9927],{9879:function(e){e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new network object of the name i.e `name`. \\n\\nInternally, a folder is created for each newly created network object, which\\ntoo is named to `name`, but the folder it self is initially parented to `nil` \\nso the network object isn\'t available to the client - call [NetworkServer:Dispatch] \\nin order to render the network object accessible to the client.","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"middleware","desc":"","lua_type":"Middleware?"}],"returns":[{"desc":"","lua_type":"NetworkServer"}],"function_type":"static","source":{"line":138,"path":"src/Network/Server/init.lua"}},{"name":"is","desc":"Returns a boolean indicating if `self` is a network object or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":165,"path":"src/Network/Server/init.lua"}},{"name":"dispatched","desc":"Returns a boolean indicating if the network object is dispatched to the \\nclient or not. \\n\\n:::note\\nThis method will always return false if the network object is destroyed.\\n:::","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":178,"path":"src/Network/Server/init.lua"}},{"name":"append","desc":"Appends a key value pair, `key` and `value`, to the network object, so that\\nit is available to the client once the network object is dispatched. \\n\\nE.g:\\n\\n```lua\\n-- Server\\nlocal Network = require(...)\\n\\nlocal networkObject = Network.new(\\"test\\")\\nnetworkObject:append(\\"key\\", \\"the value!\\")\\nnetworkObject:dispatch(workspace)\\n\\n-- Client\\nlocal networkObject = Network.fromServer(\\"test\\", workspace):expect()\\nprint(networkObject.key) --\x3e \\"the value!\\"\\n```\\n\\t\\n:::note\\n[Argument limitations](https://create.roblox.com/docs/scripting/events/argument-limitations-for-bindables-and-remotes)\\ndo apply since remote functions are internally used to replicate the appended\\nkey value pairs to the client.\\n:::\\n\\n:::warning\\nThis method will error if the network object is dispatched to the client. \\nAlways make sure to append keys and values *before* you dispatch the \\nnetwork object. You can check if a network object is dispatched to the \\nclient or not through [NetworkServer:dispatched].\\n:::","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"RemoteProperty | RemoteSignal | any"}],"returns":[],"function_type":"method","source":{"line":217,"path":"src/Network/Server/init.lua"}},{"name":"dispatch","desc":"Dispatches the network folder of the network object to `parent`, rendering\\nthe network object accessible to the client now.\\n\\n:::warning\\nIf another network object of the same name as this network object, is already\\ndispatched to `parent`, then this method will error - you can\'t have more than \\n1 network object of the same name dispatched to the same instance!\\n:::","params":[{"name":"parent","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":241,"path":"src/Network/Server/init.lua"}},{"name":"destroy","desc":"Destroys the network object and all appended remote properties / \\nremote signals within the network object, and renders the network \\nobject useless. ","params":[],"returns":[],"function_type":"method","source":{"line":263,"path":"src/Network/Server/init.lua"}}],"properties":[],"types":[{"name":"Middleware","desc":"Both `Inbound` and `Outbound` should be array of callbacks (if specified, none of them are required). \\nCallbacks in `Inbound` are known as \\"inbound callbacks\\" and are called whenever a client tries to call \\na serverside method  (exposed through the network object). The first argument passed to each inbound \\ncallback is the name of the method (the client called), and the arguments sent by the client (to that method)\\nare packed into an array, which is then passed as the second argument. \\n\\n```lua\\nlocal inboundCallbacks = {\\n\\tfunction (methodName, arguments)\\n\\t\\tprint(arguments[1]:IsA(\\"Player\\")) --\x3e true (first argument is always the client)\\n\\t\\targuments[2] = \\"booooo\\" --\x3e You can modify the arguments !\\n\\tend\\n}\\n---\\n```\\n\\n:::tip Automatic method call rejection\\nIf any inbound callback returns an **explicit** false value, then the method (which the client tried to call) will *not* be\\ncalled. This is good, e.g for implementing queues!\\n:::\\n\\nCallbacks in `Outbound` are known as \\"outbound callbacks\\" and are called whenever a serverside method \\n(exposed through the network object) is called by the client, and has **finished**. The first argument passed to \\neach inbound callback is the name of the method (the client called), and the arguments sent by the client (to that method)\\nare packed into an array, which is then passed as the second argument. \\n\\n```lua\\nlocal outboundCallbacks = {\\n\\tfunction (methodName, arguments)\\n\\t\\tprint(arguments[1]:IsA(\\"Player\\")) --\x3e true (first argument is always the client)\\n\\tend\\n}\\n---\\n```\\n\\n:::tip \\nFor outbound callbacks, an additional member in the arguments array, i.e `response` is injected automatically, which is \\nthe response of the serverside method (which the client called). This means you can modify the response of the serverside method\\nbefore it is returned back to the client, e.g:\\n\\n```lua\\n-- Server:\\nlocal Network = require(...)\\n\\nlocal middleware = {\\n\\t{\\n\\t\\tfunction (methodName, arguments)\\n\\t\\t\\targuments.response = \\"oops modified\\" \\n\\t\\tend\\n\\t}\\n}\\nlocal networkObject = Network.new(\\"test\\", middleware)\\nnetworkObject:append(\\"SomeMethod\\", function()\\n\\treturn \\"this\\"\\nend)\\nnetworkObject:dispatch(workspace)\\n\\n-- Client:\\nlocal Network = require(...)\\n\\nlocal networkObject = Network.FromName(\\"test\\", workspace):expect()\\nprint(networkObject.SomeMethod()) --\x3e \\"oops modified\\" (ought to print \\"this\\")\\n```\\n:::","fields":[{"name":"inbound","lua_type":"{(args: {...any}) -> ()}?","desc":""},{"name":"outbound","lua_type":"{(args: {...any}) -> ()}?","desc":""}],"source":{"line":78,"path":"src/Network/Server/init.lua"}}],"name":"NetworkServer","desc":"The server counterpart of the Network module.","source":{"line":6,"path":"src/Network/Server/init.lua"}}')}}]);